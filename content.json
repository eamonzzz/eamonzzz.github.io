{"meta":{"title":"EamonBlog","subtitle":"Eamon 的个人博客","description":"付出不亚于任何人的努力","author":"Eamon Zhang","url":"https://www.eamonzhang.com"},"pages":[{"title":"关于我","date":"2020-04-20T13:30:54.000Z","updated":"2020-04-20T14:20:30.385Z","comments":true,"path":"about/index.html","permalink":"https://www.eamonzhang.com/about/index.html","excerpt":"","text":"Eamon document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-20T13:29:57.000Z","updated":"2020-04-20T13:31:23.336Z","comments":true,"path":"categories/index.html","permalink":"https://www.eamonzhang.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-04-20T13:29:57.000Z","updated":"2020-04-20T13:30:18.147Z","comments":true,"path":"tags/index.html","permalink":"https://www.eamonzhang.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-20T13:31:32.000Z","updated":"2020-04-20T13:31:47.724Z","comments":true,"path":"contact/index.html","permalink":"https://www.eamonzhang.com/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-04-20T14:22:29.000Z","updated":"2020-04-20T14:22:46.764Z","comments":true,"path":"friends/index.html","permalink":"https://www.eamonzhang.com/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"使用GitHub+jsDelivr 制作免费图床","slug":"使用GitHub-jsDelivr-制作免费图床","date":"2020-05-17T09:41:16.000Z","updated":"2020-05-17T13:09:26.052Z","comments":true,"path":"posts/66dce0e3.html","link":"","permalink":"https://www.eamonzhang.com/posts/66dce0e3.html","excerpt":"","text":"获得github的token 点击个人头像 选择设置 进入 Developer settings 选择 Personal access tokens ，然后点击 Generate new token 生成时，权限设置如下 生成之后，复制该 token 下载图片上传工具推荐使用 PicGo : https://github.com/Molunerfinn/PicGo 设置github图床注意：因为某些原因，上传到 github 的图片是不能直接访问的，所以需要绕一步，这里选择免费的 jsdelivr CDN加速。网址：jsdelivr.com 为了在上传完成时，picgo 能够自动将访问连接设置成 CDN 加速后的连接，这里需要设置自定义域名，格式为： https://cdn.jsdelivr.net/gh/用户名/图床仓库名 ，如图所示 上传测试 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"https://www.eamonzhang.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.eamonzhang.com/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://www.eamonzhang.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"设计模式-委派模式","slug":"设计模式-委派模式","date":"2019-10-28T05:52:38.000Z","updated":"2020-04-20T14:02:57.506Z","comments":true,"path":"posts/a77bbab9.html","link":"","permalink":"https://www.eamonzhang.com/posts/a77bbab9.html","excerpt":"首先委派模式不属于23种设计模式。 所谓委派，个人理解是：将为达到最终结果的事情交给其他人或中间人来干，我只要最终结果，其他的事情，由我委派的人来安排。","text":"首先委派模式不属于23种设计模式。 所谓委派，个人理解是：将为达到最终结果的事情交给其他人或中间人来干，我只要最终结果，其他的事情，由我委派的人来安排。 更直白的表达就是，比如，我们想要盖一栋楼房，盖完之后我要刷漆，这些事情我自己肯定不能做，所以我这时候就会去找一个“包工头”来帮我完成这件事情，我只要告诉“包工头”我要盖房子、我要给房子刷漆等命令，其他的事情我不管，最终能够交付给我这个刷完漆房子就行。那么“包工头”也不可能自己来干的吧，这个时候他就会去找人，盖楼房的、刷漆的等等；然后叫他们来干这件事情，干完之后，交付给我一个刷完漆的房子即可。这个过程也就是委派模式的一个体现。 委派模式看上去和我们之前所说的“静态模式”非常相似，它可以说是一种特殊情况的静态代理的全权代理。但是也是有区别的，“静态代理”更注重的是过程，而“委派模式”只注重“结果”。 示例我们现在就以上述中的例子，用代码来实现以下： 代码先创建工人抽象类接口，他们都具有干活的功能 Worker ： /** * 抽象 工人 * * @author EamonZzz * @date 2019-10-26 15:09 */ public interface Worker { /** * 干活 * * @param command 听命令干活 */ void doWork(String command); } 然后有一个工人A，砌砖砌的很好，很适合盖楼，WorkerA： /** * 工人A 他砌砖砌的很好，所以叫来盖楼比较好 * * @author EamonZzz * @date 2019-10-26 15:11 */ public class WorkerA implements Worker { @Override public void doWork(String command) { System.out.println(\"我是工人A，包工头叫我 \" + command); } } 然后再来一个工人B，他是专业刷漆的 WorkerB： /** * 工人A 他砌砖砌的很好，所以叫来盖楼比较好 * * @author EamonZzz * @date 2019-10-26 15:11 */ public class WorkerA implements Worker { @Override public void doWork(String command) { System.out.println(\"我是工人A，包工头叫我 \" + command); } } 再来找一个包工头，包工头也是一名工人，但是这个包工头主要是组织工人干活，Contractor： /** * 包工头(也是一名工人)，承接项目，分配工人 * * @author EamonZzz * @date 2019-10-26 15:07 */ public class Contractor implements Worker { private Map&lt;String,Worker> targets = new HashMap&lt;String, Worker>(); public Contractor() { targets.put(\"盖楼\", new WorkerA()); targets.put(\"刷漆\", new WorkerB()); } /** * 包工头不需要自己干活 * @param command */ @Override public void doWork(String command) { targets.get(command).doWork(command); } } 最后就是有盖楼刷漆的需求的人，Boss： /** * 我，需要盖楼的人，给包工头下达盖楼、刷漆的命令 * * @author EamonZzz * @date 2019-10-26 15:06:09 **/ public class Boss { /** * 下达 请求 * * @param command * @param contractor */ public void command(String command, Contractor contractor) { contractor.doWork(command); } } 来看一下测试类： /** * @author EamonZzz * @date 2019-10-26 15:23 */ public class BossTest { @Test public void test() { Boss boss = new Boss(); boss.command(\"盖楼\", new Contractor()); boss.command(\"刷漆\", new Contractor()); } } 最终结果： 我是工人A，包工头叫我 盖楼 我是工人B，包工头叫我 刷漆 类图 这个过程就模拟完毕，Boss 给包工头下达命令说我要盖楼，然后包工头就去找能够盖楼的人去盖楼；然后下达命令说，我的楼房需要刷漆了，包工头就去找刷漆的人来干这件事情。 SpringMVC中使用委派模式的场景在SpringMVC中，也有委派模式的身影，比如我们最常见的 DispatcherServlet 它用来将我们前端URL传过来的请求，分发到相应的 Controller 控制器来处理请求，那么它是怎么来完成这一过程的呢？ 其实结合上面的实例场景就不难分析出来原理。 总结对于“委派模式”和“静态代理模式”的区别，在文章开头已经提到过，“静态代理”注重过程，代理类和被代理类都要去实现一个接口；而“委派模式”更注重结果，Boss不需要实现Worker 这个接口。就拿敲代码这个能力来说，“静态代理”的Boss类需要会敲代码，而“委派模式”中的Boss则不需要会敲代码。 源码地址：https://github.com/eamonzzz/java-advanced/tree/… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-动态代理原理及模仿JDK Proxy写一个属于自己的动态代理","slug":"设计模式-动态代理原理及模仿JDK Proxy写一个属于自己的动态代理","date":"2019-10-27T15:18:31.000Z","updated":"2020-04-20T14:02:57.504Z","comments":true,"path":"posts/e9783717.html","link":"","permalink":"https://www.eamonzhang.com/posts/e9783717.html","excerpt":"本篇文章代码内容较多，讲的可能会有些粗糙，大家可以选择性阅读。 本篇文章的目的是简单的分析动态代理的原理及模仿JDK Proxy手写一个动态代理以及对几种代理做一个总结。","text":"本篇文章代码内容较多，讲的可能会有些粗糙，大家可以选择性阅读。 本篇文章的目的是简单的分析动态代理的原理及模仿JDK Proxy手写一个动态代理以及对几种代理做一个总结。 对于代理模式的介绍和讲解，网上已经有很多优质的文章，我这里就不会再过多的介绍了，这里推荐几篇优质的文章作为参考： 给女朋友讲解什么是代理模式 轻松学，Java 中的代理模式及动态代理 另外，我的 github 仓库对应目录中也有相关的基础示例代码：https://github.com/eamonzzz/java-advanced… JDK Proxy 动态代理动态代理的概念这里就不再阐述了；动态代理相对于静态代理来说，它的功能更加强大，随着业务的扩展，适应性更强。 在说动态代理原理之前，我们还是来看看动态代理的一般使用。 使用本篇文章的使用示例，是以一个最为简单的代理模式的代码为例，相信大家在学习或了解代理模式的时候都有看到或者接触过这些代码。 先创建一个Subject主体抽象接口： /** * @author eamon.zhang * @date 2019-10-09 下午4:06 */ public interface Subject { void request(); } 再创建一个真实的主体RealSubject来处理我们的真实的逻辑： /** * @author eamon.zhang * @date 2019-10-09 下午4:06 */ public class RealSubject implements Subject { @Override public void request() { System.out.println(\"真实处理逻辑！\"); } } 在不修改RealSubject类的情况下，如果我们要实现在执行RealSubject类中request()方法之前或之后执行一段逻辑的话，该怎么实现呢？这就得创建一个代理类，来达到增强原有代码的目的。所以现在创建一个 JDK 动态代理类 RealSubjectJDKDynamicProxy ： /** * @author eamon.zhang * @date 2019-10-09 下午4:08 */ public class RealSubjectJDKDynamicProxy implements InvocationHandler { // 被代理对象的引用 private Object target; // 通过构造器传入对象引用 public RealSubjectJDKDynamicProxy(Object target) { this.target = target; } // 获得 JDK 动态代理创建的代理对象 public Object getInstance() { Class&lt;?> clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); } @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable { before(); // 代理执行被代理对象的相应方法 Object invoke = method.invoke(target, objects); after(); return invoke; } private void before() { System.out.println(\"前置增强！\"); } private void after() { System.out.println(\"后置增强！\"); } } 测试代码： @Test public void test(){ Subject realSubject = new RealSubject(); RealSubjectJDKDynamicProxy proxy = new RealSubjectJDKDynamicProxy(realSubject); Subject instance = (Subject) proxy.getInstance(); instance.request(); System.out.println(realSubject.getClass()); System.out.println(instance.getClass()); } 测试结果 前置增强！ 真实处理逻辑！ 后置增强！ class com.eamon.javadesignpatterns.proxy.dynamic.jdk.RealSubject class com.sun.proxy.$Proxy8从结果来看，上面的代码已经达到了我们的增强的目的。 原理分析不知道大家有没有注意到上面的测试代码中，最后两行我将代理之前和代理之后的class对象给打印了出来；并且发现，这两个对象并非同一个，最重要的是，经过代理之后的对象的Subject是com.sun.proxy.$Proxy8而不是com.eamon.javadesignpatterns.proxy.dynamic.jdk.RealSubject或者com.eamon.javadesignpatterns.proxy.dynamic.jdk.Subject，那么这个instance到底是从哪里来？带着这个疑问，我们来通过 JDK Proxy 源码来分析一下： 我们跟进RealSubjectJDKDynamicProxy类中的Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h) throws IllegalArgumentException { Objects.requireNonNull(h); final Class&lt;?>[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkProxyAccess(Reflection.getCallerClass(), loader, intfs); } /* * Look up or generate the designated proxy class. */ Class&lt;?> cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try { ... final Constructor&lt;?> cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) { AccessController.doPrivileged(new PrivilegedAction&lt;Void>() { public Void run() { cons.setAccessible(true); return null; } }); } return cons.newInstance(new Object[]{h}); } catch (IllegalAccessException|InstantiationException e) { throw new InternalError(e.toString(), e); } ... } 发现在newProxyInstance方法中调用了getProxyClass0(loader, intfs)方法，我们跟进去这个方法看一下： /** * Generate a proxy class. Must call the checkProxyAccess method * to perform permission checks before calling this. */ private static Class&lt;?> getProxyClass0(ClassLoader loader, Class&lt;?>... interfaces) { if (interfaces.length > 65535) { throw new IllegalArgumentException(\"interface limit exceeded\"); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); } 代码逻辑很简单，做了两个事情： 检查类的接口数量是否超过65535,接口个数用 2 个 byte 存储，最大支持 65535 个。 从 proxyClassCache 缓存中去取，从注释中可知，如果缓存没有就会调用ProxyClassFactory去创建。 我们现在就来简单分析一下proxyClassCache.get(loader, interfaces)里面的逻辑： public V get(K key, P parameter) { Objects.requireNonNull(parameter); expungeStaleEntries(); Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey ConcurrentMap&lt;Object, Supplier&lt;V>> valuesMap = map.get(cacheKey); if (valuesMap == null) { ConcurrentMap&lt;Object, Supplier&lt;V>> oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;>()); if (oldValuesMap != null) { valuesMap = oldValuesMap; } } // create subKey and retrieve the possible Supplier&lt;V> stored by that // subKey from valuesMap Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V> supplier = valuesMap.get(subKey); Factory factory = null; // 这里是一个 while（true） while (true) { // 如果创建 factory（这里指ProxyClassFactory） 成功，就调用 factory.get()方法 if (supplier != null) { // supplier might be a Factory or a CacheValue&lt;V> instance // V value = supplier.get(); if (value != null) { return value; } } // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // lazily construct a Factory if (factory == null) { factory = new Factory(key, parameter, subKey, valuesMap); } if (supplier == null) { supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) { // successfully installed Factory supplier = factory; } // else retry with winning supplier } else { if (valuesMap.replace(subKey, supplier, factory)) { // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; } else { // retry with current supplier supplier = valuesMap.get(subKey); } } } } 代码可能有点长，其实逻辑就是为了调用ProxyClassFactory.apply()去生成代理类。我们从while(true)处将代码分割成两个部分来看： 前半部分，是从缓存中去取ProxyClassFactory，如果创建成功了，则可以取到（缓存中的 key 这里不分析了） 然后看 while(true) 代码块中的逻辑，if (supplier != null)这个判断，如果缓存中创建了ProxyClassFactory就会执行supplier.get()并且终止循环；如果没有，则会执行new Factory(key, parameter, subKey, valuesMap);去创建factory，然后将其放入缓存supplier中，然后继续循环，这个时候就会执行if (supplier != null)代码块中的逻辑，我们再来分析一下这个代码块里面的代码： if (supplier != null) { // supplier might be a Factory or a CacheValue&lt;V> instance V value = supplier.get(); if (value != null) { return value; } } 跟进 supplier.get()方法去看一下，我们从上面的分析可以知道这里的supplier其实就是一个Factory，所以我们看Factory的实现，重点看get()方法： private final class Factory implements Supplier&lt;V> { ... @Override public synchronized V get() { // serialize access ... // create new value V value = null; try { value = Objects.requireNonNull(valueFactory.apply(key, parameter)); } finally { if (value == null) { // remove us on failure valuesMap.remove(subKey, this); } } // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) CacheValue&lt;V> cacheValue = new CacheValue&lt;>(value); // put into reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // try replacing us with CacheValue (this should always succeed) if (!valuesMap.replace(subKey, this, cacheValue)) { throw new AssertionError(\"Should not reach here\"); } // successfully replaced us with new CacheValue -> return the value // wrapped by it return value; } } 我们注意到，代码中的重点是在Objects.requireNonNull(valueFactory.apply(key, parameter));，那这个代码中的valueFactory是什么呢？我们在Proxy中，来看一下proxyClassCache的定义 private static final WeakCache&lt;ClassLoader, Class&lt;?>[], Class&lt;?>> proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory()); WeakCache中第二个参数是new ProxyClassFactory() ，再来看一下对应的构造器： public WeakCache(BiFunction&lt;K, P, ?> subKeyFactory, BiFunction&lt;K, P, V> valueFactory) { this.subKeyFactory = Objects.requireNonNull(subKeyFactory); this.valueFactory = Objects.requireNonNull(valueFactory); } 这时候明白了吗？其实 valueFactory就是ProxyClassFactory() 明白了这一点，就来分析一下valueFactory.apply(key, parameter)到底执行了什么？我们直接看ProxyClassFactory的代码 private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?>[], Class&lt;?>> { // prefix for all proxy class names private static final String proxyClassNamePrefix = \"$Proxy\"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?> apply(ClassLoader loader, Class&lt;?>[] interfaces) { ... /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try { return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } catch (ClassFormatError e) { throw new IllegalArgumentException(e.toString()); } } } 纵观全览，不难分析，代码中其实就是在创建$Proxy这个中间代理类，其中byte[] proxyClassFile是代码块中组装完成之后的类的字节码文件数据，通过ProxyGenerator.generateProxyClass()生成；然后通过classloader动态加载字节码，并生成动态代理类的Class实例，并返回。 我们再跟进ProxyGenerator.generateProxyClass()方法，来看看在生成代理类过程中的处理逻辑，看重点代码：。 public static byte[] generateProxyClass(final String var0, Class&lt;?>[] var1, int var2) { ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); final byte[] var4 = var3.generateClassFile(); ... return var4; } 可以发现其代码调用了var3.generateClassFile()去生成Class文件，所以我们跟进generateClassFile()方法，看重点内容： private byte[] generateClassFile() { this.addProxyMethod(hashCodeMethod, Object.class); this.addProxyMethod(equalsMethod, Object.class); this.addProxyMethod(toStringMethod, Object.class); Class[] var1 = this.interfaces; int var2 = var1.length; int var3; Class var4; for(var3 = 0; var3 &lt; var2; ++var3) { var4 = var1[var3]; Method[] var5 = var4.getMethods(); int var6 = var5.length; for(int var7 = 0; var7 &lt; var6; ++var7) { Method var8 = var5[var7]; this.addProxyMethod(var8, var4); } } ... } 代码有点长，这里就不全部展开了，有兴趣的朋友可以跟进去详细看一下。从代码中我们大致可以看出来，在生成代理类的过程中，还添加了hashCode、equals、toString这三个方法，然后后面的逻辑就是将代理对象中的所有接口进行迭代，将其所有的方法都重新生成代理方法；然后生成字节码。 最后再将代理类加载到JVM中。 看一下JDK Proxy生成的代理类$Proxy我们通过下面这段代码，将$Proxy文件输出到文件： @Test public void test1(){ System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); RealSubject realSubject = new RealSubject(); RealSubjectJDKDynamicProxy proxy = new RealSubjectJDKDynamicProxy(realSubject); Subject instance = (Subject) proxy.getInstance(); try { byte[] proxychar= ProxyGenerator.generateProxyClass(\"$Proxy0\", new Class[]{Subject.class}); OutputStream outputStream = new FileOutputStream(\"/Users/eamon.zhang/IdeaProjects/own/java-advanced/01.DesignPatterns/design-patterns/\"+instance.getClass().getSimpleName()+\".class\"); outputStream.write(proxychar); outputStream.flush(); outputStream.close(); } catch (IOException e) { e.printStackTrace(); } instance.request(); System.out.println(instance.getClass()); } 通过IDEA工具查看$Proxy0，印证一下我们之前的分析: public final class $Proxy0 extends Proxy implements Subject { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void request() throws { try { super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final int hashCode() throws { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m3 = Class.forName(\"com.eamon.javadesignpatterns.proxy.dynamic.jdk.Subject\").getMethod(\"request\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } } 总结总结一下JDK Proxy的实现步骤： 拿到被代理对象的引用，并获取它的所有接口（通过反射） JDK Proxy 类重新生成一个新的类，同时新的类要实现被代理类的所有实现的接口，还有hashCode、equals、toString这三个方法 动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现） 编译新生成的Java代码的 .class文件 重新加载到JVM中运行 仿真手写 JDK Proxy在明白了上面的原理之后，其实我们就可以尝试手动来实现一个JDK Proxy： 我们参照JDK Proxy实现原理分析一下需要动手编写哪些内容： 首先我们需要有一个代理类MimeProxy 然后从代理类出发，需要有newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this)这一个方法，方法参数为：(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)，所以我们需要创建一个ClassLoader、InvocationHandler; 下面来一步一步创建： 先创建MimeClassLoader类，继承自ClassLoader，并重写findClass()方法： /** * @author eamon.zhang * @date 2019-10-10 下午2:47 */ public class MimeClassLoader extends ClassLoader { private Object target; public MimeClassLoader(Object target) { this.target = target; } @Override protected Class&lt;?> findClass(String name) throws ClassNotFoundException { String classname = target.getClass().getPackage().getName() + \".\" + name; String filePath = MimeClassLoader.class.getResource(\"\").getPath() + name + \".class\"; try { URI uri = new URI(\"file:///\" + filePath); Path path = Paths.get(uri); File file = path.toFile(); if (file.exists()) { byte[] fileBytes = Files.readAllBytes(path); return defineClass(classname, fileBytes, 0, fileBytes.length); } } catch (Exception e) { e.printStackTrace(); } return null; } } 创建 MimeInvocationHandler 类： /** * @author eamon.zhang * @date 2019-10-10 下午2:46 */ public interface MimeInvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; } 创建MimeProxy类，这个类就是用来组装成代理类，并加载到JVM，然后返回这个代理对象： /** * @author eamon.zhang * @date 2019-10-10 下午3:08 */ public class MimeProxy { private static final String ln = \"\\r\\n\"; private static final String semi = \";\"; private static Map&lt;Class, Class> mappings = new HashMap&lt;Class, Class>(); static { mappings.put(int.class, Integer.class); } public static Object newProxyInstance(MimeClassLoader loader, Class&lt;?>[] interfaces, MimeInvocationHandler h) throws IllegalArgumentException { try { // 1. 动态生成 .java 文件 String src = generateSrc(interfaces); // System.out.println(src); // 2. java 文件输出到磁盘 String filePath = MimeProxy.class.getResource(\"\").getPath(); // System.out.println(filePath); File f = new File(filePath + \"$Proxy8.java\"); // f.deleteOnExit(); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); // 3. 把 java 文件编译成 .class 文件 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager sjfm = compiler.getStandardFileManager(null, null, null); Iterable&lt;? extends JavaFileObject> iterable = sjfm.getJavaFileObjects(f); JavaCompiler.CompilationTask task = compiler.getTask(null, sjfm, null, null, null, iterable); task.call(); sjfm.close(); // 4. 把.class 文件加载到jvm Class&lt;?> proxyClass = loader.findClass(\"$Proxy8\"); Constructor&lt;?> c = proxyClass.getConstructor(MimeInvocationHandler.class); f.delete(); // 5. 返回字节码重组以后的新的代理对象 return c.newInstance(h); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 生成 代理类 * * @param interfaces * @return */ private static String generateSrc(Class&lt;?>[] interfaces) { // 这里使用 StringBuffer 线程安全 StringBuffer sb = new StringBuffer(); sb.append(\"package \").append(interfaces[0].getPackage().getName()).append(semi).append(ln); sb.append(\"import \").append(interfaces[0].getName()).append(semi).append(ln); sb.append(\"import java.lang.reflect.*;\").append(ln); sb.append(\"import \").append(interfaces[0].getPackage().getName()).append(\".mimeproxy.MimeInvocationHandler;\").append(ln); sb.append(\"public class $Proxy8 implements \").append(interfaces[0].getSimpleName()).append(\" {\").append(ln); sb.append(\"MimeInvocationHandler h;\" + ln); sb.append(\"public $Proxy8(MimeInvocationHandler h) {\").append(ln); sb.append(\"this.h = h;\").append(ln); sb.append(\"}\").append(ln); for (Method method : interfaces[0].getMethods()) { Class&lt;?>[] params = method.getParameterTypes(); StringBuffer paramNames = new StringBuffer(); StringBuffer paramValues = new StringBuffer(); StringBuffer paramClasses = new StringBuffer(); for (Class&lt;?> clazz : params) { String type = clazz.getName(); String paramName = toLowerFirstCase(clazz.getSimpleName()); paramNames.append(type).append(\" \").append(paramName); paramValues.append(paramName); paramClasses.append(clazz.getName()).append(\".class\"); for (int i = 0; i &lt; params.length; i++) { paramNames.append(\",\"); paramValues.append(\",\"); paramClasses.append(\",\"); } } sb.append(\"public \").append(method.getReturnType().getName()).append(\" \").append(method.getName()) .append(\"(\").append(paramNames.toString()).append(\") {\").append(ln); sb.append(\"try {\").append(ln); // Method m = interfaces[0].getName().class.getMethod(method.getName()),new Class[]{paramClasses.toString()}); sb.append(\"Method m = \").append(interfaces[0].getName()).append(\".class.getMethod(\\\"\") .append(method.getName()).append(\"\\\", new Class[]{\").append(paramClasses.toString()).append(\"});\") .append(ln); // return this.h.invoke(this, m, new Object[]{paramValues}, method.getReturnType()); sb.append(hasReturnValue(method.getReturnType()) ? \"return \" : \"\") .append(getCaseCode(\"this.h.invoke(this,m,new Object[]{\" + paramValues + \"})\", method.getReturnType())) .append(\";\") .append(ln); sb.append(\"} catch (Error _ex) {}\").append(ln); sb.append(\"catch (Throwable e) {\").append(ln); sb.append(\"throw new UndeclaredThrowableException(e);\").append(ln); sb.append(\"}\"); sb.append(getReturnEmptyCode(method.getReturnType())).append(ln); sb.append(\"}\"); } sb.append(\"}\").append(ln); return sb.toString(); } /** * 获取返回值类型 * * @param returnClass * @return */ private static String getReturnEmptyCode(Class&lt;?> returnClass) { if (mappings.containsKey(returnClass)) { return \"return 0;\"; } else if (returnClass == void.class) { return \"\"; } else { return \"return null;\"; } } /** * 拼接 invocationHandler 执行代码 * * @param code * @param returnClass * @return */ private static String getCaseCode(String code, Class&lt;?> returnClass) { if (mappings.containsKey(returnClass)) { return \"((\" + mappings.get(returnClass).getName() + \")\" + code + \").\" + returnClass.getSimpleName() + \"Value()\"; } return code; } /** * 判断是否有返回值 * * @param clazz * @return */ private static boolean hasReturnValue(Class&lt;?> clazz) { return clazz != void.class; } /** * 首字母转换为小写 * * @param src * @return */ private static String toLowerFirstCase(String src) { char[] chars = src.toCharArray(); chars[0] += 32; return String.valueOf(chars); } } 这样子就编写了一个属于自己的动态代理，当然，代理方法还不完善，只是针对本示例进行了编写，有兴趣的朋友可以试试将其改为更通用的代码。 CGlib 动态代理下面来看一下 CGlib 的动态代理的使用 使用先创建RealSubject类，注意，这个类不用实现任何接口： /** * @author eamon.zhang * @date 2019-10-09 下午4:22 */ public class RealSubject { public void request(){ System.out.println(\"真实处理逻辑！\"); } } 然后创建RealSubjectCglibDynamicProxy 代理类，它必须实现MethodInterceptor接口： /** * @author eamon.zhang * @date 2019-10-09 下午4:23 */ public class RealSubjectCglibDynamicProxy implements MethodInterceptor { public Object getInstance(Class&lt;?> clazz) { // 通过CGLIB动态代理获取代理对象的过程 Enhancer enhancer = new Enhancer(); // 要把哪个设置为即将生成的新类父类 enhancer.setSuperclass(clazz); // 设置回调对象 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { before(); Object invokeSuper = proxy.invokeSuper(obj, args); after(); return invokeSuper; } private void before() { System.out.println(\"前置增强！\"); } private void after() { System.out.println(\"后置增强！\"); } } 这样，一个简单的CGlib动态代理实现就完成了，我们现在来创建测试代码： @Test public void test(){ RealSubjectCglibDynamicProxy proxy = new RealSubjectCglibDynamicProxy(); RealSubject instance = (RealSubject) proxy.getInstance(RealSubject.class); instance.request(); } 测试结果： 前置增强！ 真实处理逻辑！ 后置增强！ 原理分析不管是JDK Proxy还是CGlib，他们的核心内容都是去创建代理类，所以我们只要去了解其创建代理类的过程就 OK 了。 从上面简单的使用示例可以知道，要使用 CGlib 动态代理，代理类必须要实现MethodInterceptor（方法拦截器），MethodInterceptor接口源码如下： /** * General-purpose {@link Enhancer} callback which provides for \"around advice\". * @author Juozas Baliuka &lt;a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt&lt;/a> * @version $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $ */ public interface MethodInterceptor extends Callback { /** * All generated proxied methods call this method instead of the original method. * The original method may either be invoked by normal reflection using the Method object, * or by using the MethodProxy (faster). * @param obj \"this\", the enhanced object * @param method intercepted Method * @param args argument array; primitive types are wrapped * @param proxy used to invoke super (non-intercepted method); may be called * as many times as needed * @throws Throwable any exception may be thrown; if so, super method will not be invoked * @return any value compatible with the signature of the proxied method. Method returning void will ignore this value. * @see MethodProxy */ public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable; } 接口中只有一个intercept方法，其中传入的参数： obj 表示增强的对象，即实现这个接口类的一个对象； method 表示要被拦截的方法； args 表示方法参数； proxy 表示要触发父类的方法对象； 在创建代理对象的逻辑getInstance(Class&lt;?&gt; clazz)中，调用了enhancer.create()方法，我们跟进源码看一下： /** * Generate a new class if necessary and uses the specified * callbacks (if any) to create a new object instance. * Uses the no-arg constructor of the superclass. * @return a new instance */ public Object create() { classOnly = false; argumentTypes = null; return createHelper(); } 源码注释内容翻译：如有必要，生成一个新类，并使用指定的回调（如果有）来创建一个新的对象实例。 使用的父类的参数的构造方法来实例化父类。 它的核心内容是在createHelper();方法中： private Object createHelper() { preValidate(); Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null, ReflectUtils.getNames(interfaces), filter == ALL_ZERO ? null : new WeakCacheKey&lt;CallbackFilter>(filter), callbackTypes, useFactory, interceptDuringConstruction, serialVersionUID); this.currentKey = key; Object result = super.create(key); return result; } preValidate()方法的作用是，前置校验，校验callbackTypes、filter是否为空，以及为空时的处理。 然后通过KEY_FACTORY.newInstance()方法创建EnhancerKey对象，并将其作为super.create(key)方法的参数传入，我们来看一下这个create()方法，发现它是Enhancer类的父类AbstractClassGenerator中的一个方法： protected Object create(Object key) { try { ClassLoader loader = getClassLoader(); Map&lt;ClassLoader, ClassLoaderData> cache = CACHE; ClassLoaderData data = cache.get(loader); if (data == null) { synchronized (AbstractClassGenerator.class) { cache = CACHE; data = cache.get(loader); if (data == null) { Map&lt;ClassLoader, ClassLoaderData> newCache = new WeakHashMap&lt;ClassLoader, ClassLoaderData>(cache); data = new ClassLoaderData(loader); newCache.put(loader, data); CACHE = newCache; } } } this.key = key; Object obj = data.get(this, getUseCache()); if (obj instanceof Class) { return firstInstance((Class) obj); } return nextInstance(obj); } catch (RuntimeException e) { throw e; } catch (Error e) { throw e; } catch (Exception e) { throw new CodeGenerationException(e); } } 这个方法在最后调用了 nextInstance(obj) 方法，它对应的实现，是在Enhancer类中： protected Object nextInstance(Object instance) { EnhancerFactoryData data = (EnhancerFactoryData) instance; if (classOnly) { return data.generatedClass; } Class[] argumentTypes = this.argumentTypes; Object[] arguments = this.arguments; if (argumentTypes == null) { argumentTypes = Constants.EMPTY_CLASS_ARRAY; arguments = null; } return data.newInstance(argumentTypes, arguments, callbacks); } 这里又调用了data.newInstance(argumentTypes, arguments, callbacks)方法，第一个参数为代理对象的构造器类型，第二个为代理对象构造方法参数，第三个为对应回调对象。源码如下： public Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) { setThreadCallbacks(callbacks); try { // Explicit reference equality is added here just in case Arrays.equals does not have one if (primaryConstructorArgTypes == argumentTypes || Arrays.equals(primaryConstructorArgTypes, argumentTypes)) { // If we have relevant Constructor instance at hand, just call it // This skips \"get constructors\" machinery return ReflectUtils.newInstance(primaryConstructor, arguments); } // Take a slow path if observing unexpected argument types return ReflectUtils.newInstance(generatedClass, argumentTypes, arguments); } finally { // clear thread callbacks to allow them to be gc'd setThreadCallbacks(null); } } 我们发现这里面的逻辑的意思就是，根据传进来的参数，通过反射来生成对象，我们可以利用cglib的代理类可以将内存中的 class 文件写入本地磁盘： @Test public void test1(){ //利用 cglib 的代理类可以将内存中的 class 文件写入本地磁盘 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/Users/eamon.zhang/Documents/cglib\"); RealSubjectCglibDynamicProxy proxy = new RealSubjectCglibDynamicProxy(); RealSubject instance = (RealSubject) proxy.getInstance(RealSubject.class); instance.request(); } 执行之后，在对应的目录中可以看到生成了下图中这三个.class文件： 通过调试跟踪，我们发现 RealSubject$$EnhancerByCGLIB$$5389cdca 就是 CGLib生成的代理类，继承了 RealSubject 类。通过IDEA查看该源码： public class RealSubject$$EnhancerByCGLIB$$5389cdca extends RealSubject implements Factory { ... static void CGLIB$STATICHOOK1() { CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; Class var0 = Class.forName(\"com.eamon.javadesignpatterns.proxy.dynamic.cglib.RealSubject$$EnhancerByCGLIB$$5389cdca\"); Class var1; CGLIB$request$0$Method = ReflectUtils.findMethods(new String[]{\"request\", \"()V\"}, (var1 = Class.forName(\"com.eamon.javadesignpatterns.proxy.dynamic.cglib.RealSubject\")).getDeclaredMethods())[0]; CGLIB$request$0$Proxy = MethodProxy.create(var1, var0, \"()V\", \"request\", \"CGLIB$request$0\"); Method[] var10000 = ReflectUtils.findMethods(new String[]{\"equals\", \"(Ljava/lang/Object;)Z\", \"toString\", \"()Ljava/lang/String;\", \"hashCode\", \"()I\", \"clone\", \"()Ljava/lang/Object;\"}, (var1 = Class.forName(\"java.lang.Object\")).getDeclaredMethods()); CGLIB$equals$1$Method = var10000[0]; CGLIB$equals$1$Proxy = MethodProxy.create(var1, var0, \"(Ljava/lang/Object;)Z\", \"equals\", \"CGLIB$equals$1\"); CGLIB$toString$2$Method = var10000[1]; CGLIB$toString$2$Proxy = MethodProxy.create(var1, var0, \"()Ljava/lang/String;\", \"toString\", \"CGLIB$toString$2\"); CGLIB$hashCode$3$Method = var10000[2]; CGLIB$hashCode$3$Proxy = MethodProxy.create(var1, var0, \"()I\", \"hashCode\", \"CGLIB$hashCode$3\"); CGLIB$clone$4$Method = var10000[3]; CGLIB$clone$4$Proxy = MethodProxy.create(var1, var0, \"()Ljava/lang/Object;\", \"clone\", \"CGLIB$clone$4\"); } final void CGLIB$request$0() { super.request(); } public final void request() { MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if (var10000 == null) { CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; } if (var10000 != null) { var10000.intercept(this, CGLIB$request$0$Method, CGLIB$emptyArgs, CGLIB$request$0$Proxy); } else { super.request(); } } ... } 我们通过代理类的源码可以看到，代理类会获得所有在父类继承来的方法，并且会有 MethodProxy 与之对应，比如 Method CGLIB$request$0$Method、MethodProxy CGLIB$request$0$Proxy这些方法在代理类的 reuqest()中都有调用。 调用过程: 代理对象调用 this.request()方法 -&gt; 调用拦截器 -&gt; methodProxy.invokeSuper -&gt; CGLIB$request$0() -&gt; 被代理对象 request()方法。 此时，我们发现拦截器 MethodInterceptor 中就是由 MethodProxy 的 invokeSuper 方法调用代理方法的。 MethodProxy 非常关键，我们分析一下它具体做了什么： public class MethodProxy { private Signature sig1; private Signature sig2; private CreateInfo createInfo; private final Object initLock = new Object(); private volatile FastClassInfo fastClassInfo; /** * For internal use by {@link Enhancer} only; see the {@link net.sf.cglib.reflect.FastMethod} class * for similar functionality. */ public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) { MethodProxy proxy = new MethodProxy(); proxy.sig1 = new Signature(name1, desc); proxy.sig2 = new Signature(name2, desc); proxy.createInfo = new CreateInfo(c1, c2); return proxy; } ... private static class CreateInfo { Class c1; Class c2; NamingPolicy namingPolicy; GeneratorStrategy strategy; boolean attemptLoad; public CreateInfo(Class c1, Class c2) { this.c1 = c1; this.c2 = c2; AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent(); if (fromEnhancer != null) { namingPolicy = fromEnhancer.getNamingPolicy(); strategy = fromEnhancer.getStrategy(); attemptLoad = fromEnhancer.getAttemptLoad(); } } } ... 继续看invokeSuper()方法： public Object invokeSuper(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f2.invoke(fci.i2, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } } private static class FastClassInfo { FastClass f1; FastClass f2; int i1; int i2; } 上面代码调用过程就是获取到代理类对应的 FastClass，并执行了代理方法。还记得之前生成三个 class 文件吗？RealSubject$$EnhancerByCGLIB$$5389cdca$$FastClassByCGLIB$$57b94d72.class就是代理类的 FastClass ，RealSubject$$FastClassByCGLIB$$ed23432.class就是被代理类的FastClass。 CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了 FastClass 机 制，它的原理简单来说就是: 为代理类和被代理类各生成一个 Class，这个 Class 会为代理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK动态代理通过反射调用高。 至此，Cglib 动态代理的原理我们就基本搞清楚了，如果对代码细节有兴趣的小伙伴可以再自行深入研究。 JDK Proxy 与 CGlib 比较 JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。 JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类 比 JDK 效率低。 JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率 更高 代理模式与 SpringSpring 中的代理选择原则 当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理 当 Bean 没有实现接口时，Spring 选择 CGLib。 Spring 可以通过配置强制使用 CGLib，只需在 Spring 的配置文件中加入如下代码: &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/> 参考资料：https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html 总结静态代理和动态的本质区别 静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。 若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。 代理模式的优缺点优点 代理模式能将代理对象与真实被调用的目标对象分离。 一定程度上降低了系统的耦合度，扩展性好。 可以起到保护目标对象的作用。 可以对目标对象的功能增强 缺点 代理模式会造成系统设计中类的数量增加。 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。 增加了系统的复杂度。 本篇文章的源码目录：https://github.com/eamonzzz/java-advanced/tree/master/01.DesignPatterns/design-patterns/src/main/java/com/eamon/javadesignpatterns/proxy 测试类源码目录：https://github.com/eamonzzz/java-advanced/tree/master/01.DesignPatterns/design-patterns/src/test/java/com/eamon/javadesignpatterns/proxy 欢迎大家 star 源码，共同进步，我会按照 git 上的大纲在学习的同时，记录文章与源码~ 博主刚开始写博客不久，文中若有错误或者有任何的建议，请在留言中指出，向大家学习~ 本文由博客一文多发平台 OpenWrite 发布！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例模式之多线程调试与破坏单例","slug":"设计模式-单例模式之多线程调试与破坏单例","date":"2019-10-27T15:16:57.000Z","updated":"2020-04-20T14:02:57.505Z","comments":true,"path":"posts/7738cf8e.html","link":"","permalink":"https://www.eamonzhang.com/posts/7738cf8e.html","excerpt":"前言在之前的 设计模式 - 单例模式（详解）看看和你理解的是否一样？ 一文中，我们提到了通过Idea 开发工具进行多线程调试、单例模式的暴力破坏的问题；由于篇幅原因，现在单独开一篇文章进行演示：线程不安全的单例在多线程情况下为何被创建多个、如何破坏单例。","text":"前言在之前的 设计模式 - 单例模式（详解）看看和你理解的是否一样？ 一文中，我们提到了通过Idea 开发工具进行多线程调试、单例模式的暴力破坏的问题；由于篇幅原因，现在单独开一篇文章进行演示：线程不安全的单例在多线程情况下为何被创建多个、如何破坏单例。 如果还不知道如何使用IDEA工具进行线程模式的调试，请先阅读我之前发的一篇文章： 你不知道的 IDEA Debug调试小技巧 一、线程不安全的单例在多线程情况下为何被创建多个首先回顾简单线程不安全的懒汉式单例的代码以及测试程序代码： /** * @author eamon.zhang * @date 2019-09-30 上午10:55 */ public class LazySimpleSingleton { private LazySimpleSingleton(){} private static LazySimpleSingleton instance = null; public static LazySimpleSingleton getInstance(){ if (instance == null) { instance = new LazySimpleSingleton(); } return instance; } } // 测试程序 @Test public void test() { try { ConcurrentExecutor.execute(() -> { LazySimpleSingleton instance = LazySimpleSingleton.getInstance(); System.out.println(Thread.currentThread().getName() + \" : \" + instance); }, 2, 2); } catch (Exception e) { e.printStackTrace(); } } 对于这个单例，我们毫无疑问认为它是线程不安全的，至于为什么，接下来使用IDEA工具的线程debug模式来直观的找出答案。 在关键代码上打断点 单例类LazySimpleSingleton的if (instance == null) 处： 测试类，多线程入口调用getInstance()处： 开始调试 启动 debug ，我们可以在调试窗口找到我们启动的线程： 将 pool-1-thread-1 线程单步执行到if (instance == null) 断点处，观察instance值为null； 将pool-1-thread-1执行到instance = new LazySimpleSingleton();处等待初始化： 切换线程 pool-1-thread-2 同样单步执行到 if (instance == null) 断点处，此时观察instance值也为null（这就是我们常说的两个线程同时执行到断代码处）： 同样将pool-1-thread-2执行到instance = new LazySimpleSingleton();处等待初始化： 显然，这两个线程都满足if (instance == null) 的条件，都应该到对应的代码块中执行实例化操作，那么这两个线程就会分别初始化： 线程 pool-1-thread-1 实例化后： 切换线程 pool-1-thread-2 观察 instance 值已经被初始化了，但是，线程pool-1-thread-2 还是会被实例化一遍： 线程pool-1-thread-2实例化后： 大家是否一目了然了呢？ 将两个线程执行完，看控制台： 大家可以看到，虽然输出打印的对象是同一个，但是，确实是创建了两遍，只不过 pool-1-thread-2 实例化后将 pool-1-thread-1实例化的对象值给覆盖了。 当我将线程pool-1-thread-1和线程pool-1-thread-2同时执行到instance = new LazySimpleSingleton();处然后先让pool-1-thread-1执行完打印后，再将pool-1-thread-2执行实例化操作，就会看到打印的对象会是不一样的了： 这就是通过线程调试模式手动控制线程执行顺序来模拟还原多线程环境下，线程不安全的情况。 二、改进线程不安全的单例我们明白了线程不安全的原因是两个线程同时拿到的instance资源都为null，从而都进行实例化。那么有没有什么方法能解决呢？当然有，给 getInstance()加 上 synchronized 关键字，使这个方法变成线程同步方法： public class LazySimpleSingleton { private LazySimpleSingleton(){} private static LazySimpleSingleton instance = null; public synchronized static LazySimpleSingleton getInstance(){ if (instance == null) { instance = new LazySimpleSingleton(); } return instance; } } 当我们将其中一个线程执行并调用 getInstance()方法时，另一个线程在调用 getInstance()方法，线程的状态由 RUNNING 变成了MONITOR,出现阻塞。直到第一个线程执行完，第二个线程才恢复 RUNNING 状态继续调用 getInstance() 方法 这就解决了之前所说的线程安全问题，但是这样子在线程数量比较多情况下，如果 CPU分配压力上升，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降；为了解决线程安全和程序性能问题，于是乎有了我们的双重检查式的单例。这里就不再多说了。 三、破坏单例一般情况下，我们创建使用饿汉式单例或双重检查的懒汉式单例是没有问题的，但是在一定情况下，会发生单例被破坏。 反射破坏单例实际情况下，公司一个程序员写了一个单例，但是另外一个程序员，可能比较牛 X，写代码风格有点不一样，他通过反射来调用别人写的接口，这就会出现此单例并非彼单例的情况。这就破坏了单例。 演示在我们写单例的时候，大家有没有注意到私有的构造方法前面的修饰符仅为 private，如果我们使用反射来调用其构造方法，然后，再调用 getInstance()方法，应该就会有两个不同的实例。 我们以前面说单例的文章中的 LazyInnerClassSingleton为例，编写反射调用测试代码： @Test public void testReflex() { try { // 很无聊的情况下，进行破坏 Class&lt;LazyInnerClassSingleton> clazz = LazyInnerClassSingleton.class; // 通过反射拿到私有的构造方法 Constructor&lt;LazyInnerClassSingleton> c = clazz.getDeclaredConstructor(null); // 设置访问属性，强制访问 c.setAccessible(true); // 暴力初始化两次，这就相当于调用了两次构造方法 LazyInnerClassSingleton o1 = c.newInstance(); LazyInnerClassSingleton o2 = c.newInstance(); // 只要 o1和o2 地址不相等，就可以说明这是两个不同的对象，也就是违背了单例模式的初衷 System.out.println(o1 == o2); } catch (Exception e) { e.printStackTrace(); } } 运行结果如下： 显然，是创建了两个不同的实例。现在，我们在其构造方法中做一些限制，一旦出现多次重复创建，则直接抛出异常。来看优化后的代码： public class LazyInnerClassSingleton { private LazyInnerClassSingleton() { if(LazyHolder.INSTANCE != null){ throw new RuntimeException(\"不允许创建多个实例\"); } } // 注意关键字final，保证方法不被重写和重载 public static final LazyInnerClassSingleton getInstance() { return LazyHolder.INSTANCE; } private static class LazyHolder { // 注意 final 关键字（保证不被修改） private static final LazyInnerClassSingleton INSTANCE = new LazyInnerClassSingleton(); } } 再次调用： 至此，就避免了单例被反射破坏的问题。 序列化破坏单例另外一种情况，可能会遇到，我们需要将对象序列化到磁盘，下次使用时再从磁盘反序列化回来，反序列化的对象会被重新分配内存，那如果序列化的对象为单例，则就违背了单例模式的初衷。这也相当于破坏了单例。 演示我们还是以LazyInnerClassSingleton为例，将LazyInnerClassSingleton 实现 Serializable 接口； 然后编写测试代码： /** * @author eamon.zhang * @date 2019-10-08 下午3:06 */ public class SerializableTest { public static void main(String[] args) { LazyInnerClassSingleton s1 = null; LazyInnerClassSingleton s2 = LazyInnerClassSingleton.getInstance(); FileOutputStream fos = null; try { fos = new FileOutputStream(\"LazyInnerClassSingleton.obj\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(s2); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream(\"LazyInnerClassSingleton.obj\"); ObjectInputStream ois = new ObjectInputStream(fis); s1 = (LazyInnerClassSingleton)ois.readObject(); ois.close(); System.out.println(s1); System.out.println(s2); } catch (Exception e) { e.printStackTrace(); } } } 执行测试代码： 可以看到，结果为两个不同的对象。这同样违背了单例模式的初衷。那么我们如何保证序列化的情况也能实现单例呢？其实也很简单，使用 readResolve() 方法即可： public class LazyInnerClassSingleton implements Serializable { private LazyInnerClassSingleton() { if (LazyHolder.INSTANCE != null) { throw new RuntimeException(\"不允许创建多个实例\"); } } // 注意关键字final，保证方法不被重写和重载 public static final LazyInnerClassSingleton getInstance() { return LazyHolder.INSTANCE; } private static class LazyHolder { // 注意 final 关键字（保证不被修改） private static final LazyInnerClassSingleton INSTANCE = new LazyInnerClassSingleton(); } // 解决反序列化对象不一致问题 private Object readResolve() { return LazyHolder.INSTANCE; } } 大家肯定会问，why？ 为了一探究竟，我们来看一下 JDK 源码，我们进入 ObjectInputStream 类的 readObject()方法： public final Object readObject() throws IOException, ClassNotFoundException { if (this.enableOverride) { return this.readObjectOverride(); } else { int outerHandle = this.passHandle; Object var4; try { Object obj = this.readObject0(false); this.handles.markDependency(outerHandle, this.passHandle); ClassNotFoundException ex = this.handles.lookupException(this.passHandle); if (ex != null) { throw ex; } if (this.depth == 0L) { this.vlist.doCallbacks(); this.freeze(); } var4 = obj; } finally { this.passHandle = outerHandle; if (this.closed &amp;&amp; this.depth == 0L) { this.clear(); } } return var4; } } 我们发现：readObject 中又调用了我们重写的 readObject0()方法，进入 readObject0()方法： private Object readObject0(boolean unshared) throws IOException { ... try { switch(tc) { ... case 115: var4 = this.checkResolve(this.readOrdinaryObject(unshared)); return var4; ... } finally { --this.depth; this.bin.setBlockDataMode(oldMode); } return var4; } 我们看到代码中调用了 ObjectInputStream 的 readOrdinaryObject() 方法，我们继续进入看源码： private Object readOrdinaryObject(boolean unshared) throws IOException { ... if (cl != String.class &amp;&amp; cl != Class.class &amp;&amp; cl != ObjectStreamClass.class) { Object obj; try { obj = desc.isInstantiable() ? desc.newInstance() : null; } catch (Exception var7) { throw (IOException)(new InvalidClassException(desc.forClass().getName(), \"unable to create instance\")).initCause(var7); } ... } } 发现调用了 ObjectStreamClass 的 isInstantiable()方法，而 isInstantiable()里面的代码如下: boolean isInstantiable() { this.requireInitialized(); return this.cons != null; } 代码非常简单，就是判断一下构造方法是否为空，构造方法不为空就返回 true，也就是说，只要有无参构造方法就会实例化；这时候，其实还没有找到为什么加上readResolve()方法就避免了单例被破坏的真正原因，我们再次回到ObjectInputStream 的 readOrdinaryObject()方法继续往下看可以找到如下代码： private Object readOrdinaryObject(boolean unshared) throws IOException { ... if (obj != null &amp;&amp; this.handles.lookupException(this.passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) { Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { if (rep != null) { if (rep.getClass().isArray()) { this.filterCheck(rep.getClass(), Array.getLength(rep)); } else { this.filterCheck(rep.getClass(), -1); } } obj = rep; this.handles.setObject(this.passHandle, rep); } } ... } 判断无参构造方法是否存在之后，又调用了 hasReadResolveMethod()方法： boolean hasReadResolveMethod() { this.requireInitialized(); return this.readResolveMethod != null; } 逻辑非常简单，就是判断readResolveMethod 是否为空，不为空就返回 true。那么 readResolveMethod是在哪里赋值的呢? 通过全局查找找到了赋值代码在私有方法 ObjectStreamClass()方法中给 readResolveMethod 进行赋值，来看代码: ObjectStreamClass.this.readResolveMethod = ObjectStreamClass.getInheritableMethod(cl, \"readResolve\", (Class[])null, Object.class); 代码的逻辑其实就是通过反射找到一个无参的 readResolve()方法，并且保存下来，现在再回到 ObjectInputStream 的 readOrdinaryObject() 方法继续往下看，如果readResolve()存在则调用 invokeReadResolve()方法： Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException { this.requireInitialized(); if (this.readResolveMethod != null) { try { return this.readResolveMethod.invoke(obj, (Object[])null); } catch (InvocationTargetException var4) { Throwable th = var4.getTargetException(); if (th instanceof ObjectStreamException) { throw (ObjectStreamException)th; } else { throwMiscException(th); throw new InternalError(th); } } catch (IllegalAccessException var5) { throw new InternalError(var5); } } else { throw new UnsupportedOperationException(); } } 我们可以看到在 invokeReadResolve()方法中用反射调用了 readResolveMethod() 方法。 通过JDK源码分析我们可以看出，虽然，增加 readResolve()方法返回实例，解决了单例被破坏的问题。但是，我们通过分析源码以及调试，我们可以看到实际上实例化了两 次，只不过新创建的对象没有被返回而已. 那如果，创建对象的动作发生频率增大，就 意味着内存分配开销也就随之增大；为了解决这个问题，我们推荐使用注册式单例。 为何建议使用注册式（枚举式）单例我们在前文中说到了，我们极力推荐使用枚举类型的单例；接下来我们分析一下原因： 使用 Java 反编译工具 Jad(自行下载)，解压后，使用命令行调用： ./jad ~/IdeaProjects/own/java-advanced/01.DesignPatterns/design-patterns/build/classes/java/main/com/eamon/javadesignpatterns/singleton/enums/EnumSingleton.class会在当前目录生成一个 EnumSingleton.jad文件，我们使用 vscode 打开这个文件查看： public final class EnumSingleton extends Enum { public static EnumSingleton[] values() { return (EnumSingleton[])$VALUES.clone(); } public static EnumSingleton valueOf(String name) { return (EnumSingleton)Enum.valueOf(com/eamon/javadesignpatterns/singleton/enums/EnumSingleton, name); } private EnumSingleton(String s, int i) { super(s, i); instance = new EnumResource(); } public Object getInstance() { return instance; } public static final EnumSingleton INSTANCE; private Object instance; private static final EnumSingleton $VALUES[]; static { INSTANCE = new EnumSingleton(\"INSTANCE\", 0); $VALUES = (new EnumSingleton[] { INSTANCE }); } } 请注意这段代码： static { INSTANCE = new EnumSingleton(\"INSTANCE\", 0); $VALUES = (new EnumSingleton[] { INSTANCE }); } 原来枚举类单例在静态代码块中就给INSTANCE 赋了值，是饿汉式单例的实现方式。那么同样的，我们能否通过反射和序列化方式进行破坏呢？ 先分析通过序列化方式： 我们还是回到JDK源码：在 ObjectInputStream 的 readObject0()方法中有如下代码： private Object readObject0(boolean unshared) throws IOException { ... case 126: var4 = this.checkResolve(this.readEnum(unshared)); ... return var4; } 我们看到 readObject0()中调用了readEnum()方法，跟进该方法： private Enum&lt;?> readEnum(boolean unshared) throws IOException { if (this.bin.readByte() != 126) { throw new InternalError(); } else { ObjectStreamClass desc = this.readClassDesc(false); if (!desc.isEnum()) { throw new InvalidClassException(\"non-enum class: \" + desc); } else { int enumHandle = this.handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { this.handles.markException(enumHandle, resolveEx); } String name = this.readString(false); Enum&lt;?> result = null; Class&lt;?> cl = desc.forClass(); if (cl != null) { try { Enum&lt;?> en = Enum.valueOf(cl, name); result = en; } catch (IllegalArgumentException var9) { throw (IOException)(new InvalidObjectException(\"enum constant \" + name + \" does not exist in \" + cl)).initCause(var9); } if (!unshared) { this.handles.setObject(enumHandle, result); } } this.handles.finish(enumHandle); this.passHandle = enumHandle; return result; } } } 我们发现枚举类型其实通过类名和 Class 对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。 那么是否可以通过反射进行破坏呢？我们先来执行以下反射破坏枚举类的测试代码： @Test public void testEnum(){ try { // 很无聊的情况下，进行破坏 Class&lt;EnumSingleton> clazz = EnumSingleton.class; // 通过反射拿到私有的构造方法 Constructor&lt;EnumSingleton> c = clazz.getDeclaredConstructor(null); // 设置访问属性，强制访问 c.setAccessible(true); // 暴力初始化两次，这就相当于调用了两次构造方法 EnumSingleton o1 = c.newInstance(); EnumSingleton o2 = c.newInstance(); // 只要 o1和o2 地址不相等，就可以说明这是两个不同的对象，也就是违背了单例模式的初衷 System.out.println(o1 == o2); } catch (Exception e) { e.printStackTrace(); } } 执行结果： 报的是 java.lang.NoSuchMethodException 异常，意思是没找到无参的构造方法。 那么我们来看一下 java.lang.Enum 的源码，我们发现它只有一个protected的构造方法: protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } 那我们来做一个这样的测试： @Test public void testEnum1() { try { Class clazz = EnumSingleton.class; Constructor c = clazz.getDeclaredConstructor(String.class, int.class); c.setAccessible(true); EnumSingleton enumSingleton = (EnumSingleton) c.newInstance(\"Eamon\", 666); } catch (Exception e) { e.printStackTrace(); } } 发现控制台输出如下错误： 意思就是不能用反射来创建枚举类型。至于为什么，我们还是来看 JDK 源码，进入Constructor的newInstance()方法中： public T newInstance(Object... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!this.override) { Class&lt;?> caller = Reflection.getCallerClass(); this.checkAccess(caller, this.clazz, this.clazz, this.modifiers); } if ((this.clazz.getModifiers() &amp; 16384) != 0) { throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); } else { ConstructorAccessor ca = this.constructorAccessor; if (ca == null) { ca = this.acquireConstructorAccessor(); } T inst = ca.newInstance(initargs); return inst; } } 原来，在源码中对枚举类型进行了强制性的判断（16384代表枚举类型）,如果是枚举类型，直接抛异常。到此为止也就说明了为什么《Effective Java》推荐使用枚举来实现单例的原因： JDK 枚举的语法特殊性，以及反射也为枚举保驾护航，让枚举式单例成为一种比较优雅的实现。 本文中所涉及的源码可在 github 上找到，相关的测试代码在 test 包下：https://github.com/eamonzzz/java-advanced document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Debug调试小技巧","slug":"Debug调试小技巧","date":"2019-10-27T15:14:45.000Z","updated":"2020-04-20T14:40:57.860Z","comments":true,"path":"posts/28d4a20f.html","link":"","permalink":"https://www.eamonzhang.com/posts/28d4a20f.html","excerpt":"一、多线程调试断点Intellij IDEA 的debug断点调试是有一个模式的选择的，就像下面这张图，平时我们都使用的是默认的 ALL（在Eclipse中默认是线程模式） ，这种模式我们只能将一个线程断下来，但其他线程却已经执行过了；而将其改为 Thread 后，就可以多个线程都断下来，并且可以很方便的切换线程的执行流程，这就是多线程调试。","text":"一、多线程调试断点Intellij IDEA 的debug断点调试是有一个模式的选择的，就像下面这张图，平时我们都使用的是默认的 ALL（在Eclipse中默认是线程模式） ，这种模式我们只能将一个线程断下来，但其他线程却已经执行过了；而将其改为 Thread 后，就可以多个线程都断下来，并且可以很方便的切换线程的执行流程，这就是多线程调试。 在debug控制台能够很方便的查看线程的执行状态，也可以很方便的选择某个线程去执行： 二、回退断点不知道大伙有没有遇到这样一个问题，当我们进行debug时，通常不会进入某个方法一步一步的执行，而是选择性的跳过；当你想要回头观察某个变量的值得变化时，而你刚好没有跟进去，跳过了这个方法，这个时候，变量就被赋值了，我们通常的做法是重来一次。 其实IDEA的调试功能是非常强大的，我们来看看熟悉的调试窗口： 使用红色框框出来的部分，表示当前程序执行到哪一块，哪一部分，你可以尝试用鼠标点点看，你会发现编辑器会跳转到对应的代码中，当然当前断点的位置通常会在列表的第一条。然后我们使用右键单击，你就可以看到如下图所示： 或者你也可以在下图中找到 Drop Frame： 在IDEA中，所谓的回退，叫 Drop Frame，选择Drop Frame后，程序会跳转回调用当前这个方法的地方，当然已经改变的值是不会恢复的。但是当该方法再次被调用时，你可以观察到某个变量什么时候被改变，至少我们不用再去重新运行一遍程序。 三、条件断点条件断点就是当满足某个条件（通常是表达式）时，debug断点才会生效；这在循环中debug是非常有用的；例如我们想要在循环体中调试：当某个变量满足某个条件时，需要断点调试，来查看详细的执行流程及变化情况。 我们说过，IDEA中的debug功能是非常强大的，要使用条件断点也非常简单，下面这张图片中 Condition中的内容代表当name为eamon:23时，程序执行到断点处停下来。 有了条件断点，这样一来，那些不相关和我们不关心的代码就可以直接跳过了。 四、临时断点所谓临时断点就是只断一次，IDEA默认断点会一致存在。如果你只需要暂停一次，那么使用临时断点会比较方便，因为暂停一次之后断点就自动消失了，不用手动取消。 临时断点可以通过在打断点时按住 Alt 或者 option 键，然后创建断点。也可以通过右键断点处，选择 more 然后在窗口中选中 Remove once hit 五、求值计算求值计算功能在我们debug过程中，可以很方便的查看程序中所有变量的值，也可以临时修改程序中变量的值，这个功能能在一定程度上辅助我们进行代码调试。 这个功能可以在debug时在debug窗口打开： 打开后是这样的： 然后你就可以在表达式输入框中，输入你想要的操作，比如，查看变量、修改变量（临时的）、调用某个方法等；这些操作结果将会在下方的Result 窗口中输出。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"https://www.eamonzhang.com/categories/Intellij-IDEA/"},{"name":"工具","slug":"Intellij-IDEA/工具","permalink":"https://www.eamonzhang.com/categories/Intellij-IDEA/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"https://www.eamonzhang.com/tags/Intellij-IDEA/"},{"name":"工具","slug":"工具","permalink":"https://www.eamonzhang.com/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"https://www.eamonzhang.com/categories/Intellij-IDEA/"},{"name":"工具","slug":"Intellij-IDEA/工具","permalink":"https://www.eamonzhang.com/categories/Intellij-IDEA/%E5%B7%A5%E5%85%B7/"}]},{"title":"设计模式-单例模式（详解）看看和你理解的是否一样？","slug":"设计模式-单例模式（详解）看看和你理解的是否一样？","date":"2019-10-27T15:12:50.000Z","updated":"2020-04-20T14:02:57.505Z","comments":true,"path":"posts/8ece96c4.html","link":"","permalink":"https://www.eamonzhang.com/posts/8ece96c4.html","excerpt":"一、概述单例模式是设计模式中相对简单且非常常见的一种设计模式，但是同时也是非常经典的高频面试题，相信还是有很多人在面试时会挂在这里。本篇文章主要针对单例模式做一个回顾，记录单例模式的应用场景、常见写法、针对线程安全进行调试（看得见的线程）以及总结。相信大家看完这篇文章之后，对单例模式有一个非常深刻的认识。","text":"一、概述单例模式是设计模式中相对简单且非常常见的一种设计模式，但是同时也是非常经典的高频面试题，相信还是有很多人在面试时会挂在这里。本篇文章主要针对单例模式做一个回顾，记录单例模式的应用场景、常见写法、针对线程安全进行调试（看得见的线程）以及总结。相信大家看完这篇文章之后，对单例模式有一个非常深刻的认识。 文章中按照常见的单例模式的写法，由浅入深进行讲解记录；以及指出该写法的不足，从而进行演进改造。 秉承废话少说的原则，我们下面快速开始 二、定义单例模式(Singleton Pattern)是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。 单例模式是创建型模式。 三、应用场景 生活中的单例：例如，国家主席、公司 CEO、部门经理等。 在Java世界中：ServletContext、 ServletContextConfig 等; 在 Spring 框架应用中：ApplicationContext、数据库的连接池也都是单例形式。 四、常见的单例模式写法 单例模式主要有：饿汉式单例、懒汉式单例（线程不安全型、线程安全型、双重检查锁类型、静态内部类类型）、注册式（登记式）单例（枚举式单例、容器式单例）、ThreadLocal线程单例 下面我们来看看各种模式的写法。 1、饿汉式单例饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题。 Spring 中 IOC 容器 ApplicationContext 就是典型的饿汉式单例 优缺点优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。 缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎。 写法/** * @author eamon.zhang * @date 2019-09-30 上午9:26 */ public class HungrySingleton { // 1.私有化构造器 private HungrySingleton (){} // 2.在类的内部创建自行实例 private static final HungrySingleton instance = new HungrySingleton(); // 3.提供获取唯一实例的方法（全局访问点） public static HungrySingleton getInstance(){ return instance; } } 还有另外一种写法，利用静态代码块的机制： /** * @author eamon.zhang * @date 2019-09-30 上午10:46 */ public class HungryStaticSingleton { // 1. 私有化构造器 private HungryStaticSingleton(){} // 2. 实例变量 private static final HungryStaticSingleton instance; // 3. 在静态代码块中实例化 static { instance = new HungryStaticSingleton(); } // 4. 提供获取实例方法 public static HungryStaticSingleton getInstance(){ return instance; } } 测试代码,我们创建 10 个线程（具体线程发令枪 ConcurrentExecutor 在文末源码中获取）： /** * @author eamon.zhang * @date 2019-09-30 上午11:17 */ public class HungrySingletonTest { @Test public void test() { try { ConcurrentExecutor.execute(() -> { HungrySingleton instance = HungrySingleton.getInstance(); System.out.println(Thread.currentThread().getName() + \" : \" + instance); }, 10, 10); } catch (Exception e) { e.printStackTrace(); } } } 测试结果： pool-1-thread-6 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-9 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-10 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-7 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 pool-1-thread-8 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6 ...可以看到，饿汉式每次获取实例都是同一个。 使用场景这两种写法都非常的简单，也非常好理解，饿汉式适用在单例对象较少的情况。 下面我们来看性能更优的写法——懒汉式单例。 2、懒汉式单例懒汉式单例的特点是:被外部类调用的时候内部类才会加载。 懒汉式单例可以分为下面这几种写法来。 简单懒汉式（线程不安全）这是懒汉式单例的简单写法 /** * @author eamon.zhang * @date 2019-09-30 上午10:55 */ public class LazySimpleSingleton { private LazySimpleSingleton(){} private static LazySimpleSingleton instance = null; public static LazySimpleSingleton getInstance(){ if (instance == null) { instance = new LazySimpleSingleton(); } return instance; } } 我们创建一个多线程来测试一下，是否线程安全： /** * @author eamon.zhang * @date 2019-09-30 上午11:12 */ public class LazySimpleSingletonTest { @Test public void test() { try { ConcurrentExecutor.execute(() -> { LazySimpleSingleton instance = LazySimpleSingleton.getInstance(); System.out.println(Thread.currentThread().getName() + \" : \" + instance); }, 5, 5); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@748e48d0 pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f 从测试结果来看，一定几率出现创建两个不同结果的情况，意味着上面的单例存在线程安全隐患。 至于为什么？由于篇幅问题，我们在后面一篇文章中利用测试工具进行详细的分析（这可能也是面试中面试官会问到的问题）。大家现在只需要知道简单的懒汉式会存在这么一个问题就行了。 简单懒汉式（线程安全）通过对上面简单懒汉式单例的测试，我们知道存在线程安全隐患，那么，如何来避免或者解决呢？ 我们都知道 java 中有一个synchronized可以来对共享资源进行加锁，保证在同一时刻只能有一个线程拿到该资源，其他线程只能等待。所以，我们对上面的简单懒汉式进行改造，给getInstance() 方法加上synchronized： /** * @author eamon.zhang * @date 2019-09-30 上午10:55 */ public class LazySimpleSyncSingleton { private LazySimpleSyncSingleton() { } private static LazySimpleSyncSingleton instance = null; public synchronized static LazySimpleSyncSingleton getInstance() { if (instance == null) { instance = new LazySimpleSyncSingleton(); } return instance; } } 然后使用发令枪进行测试： @Test public void testSync(){ try { ConcurrentExecutor.execute(() -> { LazySimpleSyncSingleton instance = LazySimpleSyncSingleton.getInstance(); System.out.println(Thread.currentThread().getName() + \" : \" + instance); }, 5, 5); } catch (Exception e) { e.printStackTrace(); } } 进行多轮测试，并观察结果，发现能够获取同一个示例： pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de 线程安全问题是解决了，但是，用synchronized加锁，在线程数量比较多情况下，如果CPU分配压力上升，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降。 那么，有没有一种更好的方式，既兼顾线程安全又提升程序性能呢？答案是肯定的。 我们来看双重检查锁的单例模式。 双重检查锁懒汉式上面的线程安全方式的写法，synchronized锁是锁在 getInstance() 方法上，当多个线程过来拿资源的时候，其实需要拿的不是getInstance()这个方法，而是getInstance()方法里面的instance 实例对象，而如果这个实例对象一旦被初始化之后，多个线程到达时，就可以利用方法中的 if (instance == null) 去判断是否实例化，如果已经实例化了就直接返回，就没有必要再进行实例化一遍。所以对上面的代码进行改造： 第一次改造： /** * @author eamon.zhang * @date 2019-09-30 下午2:03 */ public class LazyDoubleCheckSingleton { private LazyDoubleCheckSingleton() { } private static LazyDoubleCheckSingleton instance = null; public static LazyDoubleCheckSingleton getInstance() { // 这里判断是为了过滤不必要的同步加锁，因为如果已经实例化了，就可以直接返回了 if (instance == null) { // 如果未初始化，则对资源进行上锁保护，待实例化完成之后进行释放 synchronized (LazyDoubleCheckSingleton.class) { instance = new LazyDoubleCheckSingleton(); } } return instance; } } 这种方法行不行？答案肯定是不行，代码中虽然是将同步锁添加到了实例化操作中，解决了每个线程由于同步锁的原因引起的阻塞，提高了性能；但是，这里会存在一个问题： 线程X和线程Y同时调用getInstance()方法，他们同时判断instance == null，得出的结果都是为null，所以进入了if代码块了 此时线程X得到CPU的控制权 -&gt; 进入同步代码块 -&gt; 创建对象 -&gt; 返回对象 线程X执行完成了以后，释放了锁，然后线程Y得到了CPU的控制权。同样是 -&gt; 进入同步代码块 -&gt; 创建对象 -&gt; 返回对象 所以我们明显可以分析出来：LazyDoubleCheckSingleton 类返回了不止一个实例！所以上面的代码是不行的！大家可以自行测试，我这里就不进行测试了！ 我们再进行改造，经过分析，由于线程X已经实例化了对象，在线程Y再次进入的时候，我们再加一层判断不就可以解决 “这个” 问题吗？确实如此，来看代码： /** * @author eamon.zhang * @date 2019-09-30 下午2:03 */ public class LazyDoubleCheckSingleton { private LazyDoubleCheckSingleton() { } private static LazyDoubleCheckSingleton instance = null; public static LazyDoubleCheckSingleton getInstance() { // 这里判断是为了过滤不必要的同步加锁，因为如果已经实例化了，就可以直接返回了 if (instance == null) { // 如果未初始化，则对资源进行上锁保护，待实例化完成之后进行释放（注意，可能多个线程会同时进入） synchronized (LazyDoubleCheckSingleton.class) { // 这里的if作用是：如果后面的进程在前面一个线程实例化完成之后拿到锁，进入这个代码块， // 显然，资源已经被实例化过了，所以需要进行判断过滤 if (instance == null) { instance = new LazyDoubleCheckSingleton(); } } } return instance; } } 大家觉得经过这样改造是不是就完美了呢？在我们习惯性的“讲道理”的思维模式看来，好像确实没什么问题，但是，程序是计算机在执行；什么意思呢？ 在 instance = new LazyDoubleCheckSingleton(); 这段代码执行的时候，计算机内部并非简单的一步操作，也就是非原子操作，在JVM中，这一行代码大概做了这么几件事情： 给 instance 分配内存 调用 LazyDoubleCheckSingleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 中的即时编译器中存在指令重排序的优化；通俗的来说就是，上面的第二步和第三步的顺序是不能保证的，如果执行顺序是 1 -&gt; 3 -&gt; 2 那么在 3 执行完毕、2 未执行之前，被另外一个线程 A 抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程 A 会直接返回 instance，然后被程序调用，就会报错。 当然，这种情况是很难测试出来的，但是确实会存在这么一个问题，所以我们必须解决它，解决方式也很简单，就是 j 将 instance 加上 volatile 关键字。 所以相对较完美的实现方式是： /** * @author eamon.zhang * @date 2019-09-30 下午2:03 */ public class LazyDoubleCheckSingleton { private LazyDoubleCheckSingleton() { } private static volatile LazyDoubleCheckSingleton instance = null; public static LazyDoubleCheckSingleton getInstance() { // 这里判断是为了过滤不必要的同步加锁，因为如果已经实例化了，就可以直接返回了 if (instance == null) { // 如果未初始化，则对资源进行上锁保护，待实例化完成之后进行释放（注意，可能多个线程会同时进入） synchronized (LazyDoubleCheckSingleton.class) { // 这里的if作用是：如果后面的进程在前面一个线程实例化完成之后拿到锁，进入这个代码块， // 显然，资源已经被实例化过了，所以需要进行判断过滤 if (instance == null) { instance = new LazyDoubleCheckSingleton(); } } } return instance; } } 测试代码见文末说明 静态内部类懒汉式上面的双重锁检查形式的单例，对于日常开发来说，确实够用了，但是在代码中使用synchronized关键字 ，总归是要上锁，上锁就会存在一个性能问题。难道就没有更好的方案吗？别说，还真有，我们从类初始化的角度来考虑，这就是这里所要说到的静态内部类的方式。 废话不多说，直接看代码： /** * * @author eamon.zhang * @date 2019-09-30 下午2:55 */ public class LazyInnerClassSingleton { private LazyInnerClassSingleton() { } // 注意关键字final，保证方法不被重写和重载 public static final LazyInnerClassSingleton getInstance() { return LazyHolder.INSTANCE; } private static class LazyHolder { // 注意 final 关键字（保证不被修改） private static final LazyInnerClassSingleton INSTANCE = new LazyInnerClassSingleton(); } } 进行多线程测试： pool-1-thread-9 : com.eamon.javadesignpatterns.singleton.lazy.inner.LazyInnerClassSingleton@88b7fa2 pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.lazy.inner.LazyInnerClassSingleton@88b7fa2 pool-1-thread-6 : com.eamon.javadesignpatterns.singleton.lazy.inner.LazyInnerClassSingleton@88b7fa2 ...结果都是同一个对象实例。 结论这种方式即解决了饿汉式的内存浪费问题，也解决了synchronized 所带来的性能问题 原理利用的原理就是类的加载初始化顺序： 当类不被调用的时候，类的静态内部类是不会进行初始化的，这就避免了内存浪费问题； 当有方法调用 getInstance()方法时，会先初始化静态内部类，而静态内部类中的成员变量是 final 的，所以即便是多线程，其成员变量是不会被修改的，所以就解决了添加 synchronized 所带来的性能问题 首先感谢也恭喜大家能够看到这里，因为我想告诉你，上面所有的单例模式似乎还存在一点小问题 —— 暴力破坏。解决这一问题的方式就是下面提到的枚举类型单例。 至于缘由和为何枚举能够解决这个问题，同样，篇幅原因，我将在后面单独开一篇文章来说明。 下面我们先来讲讲注册式单例。 3、注册式（登记式）单例注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。 注册式单例有两种写法:一种为容器缓存，一种为枚举登记。 先来看枚举式单例的写法。 枚举单例废话少说，直接看代码，我们先创建EnumResource 类： /** * @author eamon.zhang * @date 2019-09-30 下午3:53 */ public class EnumResource { } 然后创建EnumSingleton: /** * @author eamon.zhang * @date 2019-09-30 下午3:42 */ public enum EnumSingleton { INSTANCE; private Object instance; EnumSingleton() { instance = new EnumResource(); } public Object getInstance() { return instance; } } 来看测试代码： /** * @author eamon.zhang * @date 2019-09-30 下午3:47 */ public class EnumSingletonTest { @Test public void test() { try { ConcurrentExecutor.execute(() -> { EnumSingleton instance = EnumSingleton.INSTANCE; System.out.println(instance.getInstance()); }, 10, 10); } catch (Exception e) { e.printStackTrace(); } } } 测试结果： com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7 结果都一样，说明枚举类单例是线程安全的，且是不可破坏的；在 JDK 枚举的语法特殊性，以及反射也为枚举保驾护航，让枚举式单例成为一种比较优雅的实现。 枚举类单例也是《Effective Java》中所建议使用的。 容器式单例注册式单例还有另外一种写法，利用容器缓存，直接来看代码： 创建ContainerSingleton类: /** * @author EamonZzz * @date 2019-10-06 18:28 */ public class ContainerSingleton { private ContainerSingleton() { } private static Map&lt;String, Object> ioc = new ConcurrentHashMap&lt;String, Object>(); public static Object getBean(String className) { synchronized (ioc) { if (!ioc.containsKey(className)) { Object object = null; try { object = Class.forName(className).newInstance(); ioc.put(className, object); } catch (Exception e) { e.printStackTrace(); } return object; } else { return ioc.get(className); } } } } 测试代码： @Test public void test() { try { ConcurrentExecutor.execute(() -> { Object bean = ContainerSingleton .getBean(\"com.eamon.javadesignpatterns.singleton.container.Resource\"); System.out.println(bean); }, 5, 5); } catch (Exception e) { e.printStackTrace(); } } 测试结果： com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f 容器式写法适用于创建实例非常多的情况，便于管理。但是，是非线程安全的。 其实 Spring 中也有相关容器史丹利的实现代码，比如 AbstractAutowireCapableBeanFactory 接口 至此，注册式单例介绍完毕。 五、拓展ThreadLocal 线程单例ThreadLocal 不能保证其创建的对象是唯一的，但是能保证在单个线程中是唯一的，并且在单个线程中是天生的线程安全。 看代码： /** * @author EamonZzz * @date 2019-10-06 21:40 */ public class ThreadLocalSingleton { private ThreadLocalSingleton() { } private static final ThreadLocal&lt;ThreadLocalSingleton> instance = ThreadLocal.withInitial(ThreadLocalSingleton::new); public static ThreadLocalSingleton getInstance() { return instance.get(); } } 测试程序： @Test public void test() { System.out.println(\"-------------- 单线程 start ---------\"); System.out.println(ThreadLocalSingleton.getInstance()); System.out.println(ThreadLocalSingleton.getInstance()); System.out.println(ThreadLocalSingleton.getInstance()); System.out.println(ThreadLocalSingleton.getInstance()); System.out.println(ThreadLocalSingleton.getInstance()); System.out.println(\"-------------- 单线程 end ---------\"); System.out.println(\"-------------- 多线程 start ---------\"); try { ConcurrentExecutor.execute(() -> { ThreadLocalSingleton singleton = ThreadLocalSingleton.getInstance(); System.out.println(Thread.currentThread().getName() + \" : \" + singleton); }, 5, 5); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"-------------- 多线程 end ---------\"); } 测试结果： -------------- 单线程 start --------- com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda -------------- 单线程 end --------- -------------- 多线程 start --------- pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@2f540d92 pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@3ef7ab4e pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@604ffe2a pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@50f41c9f pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@40821a7a -------------- 多线程 end --------- 从测试结果来看，我们不难发现，在主线程中无论调用多少次，获得到的实例都是同一个；在多线程环境下，每个线程获取到了不同的实例。 所以，在单线程环境中，ThreadLocal 可以达到单例的目的。这实际上是以空间换时间来实现线程间隔离的。 六、总结单例模式可以保证内存里只有一个实例，减少了内存的开销；可避免对资源的浪费。 单例模式看起来非常简单，实现起来也不难，但是在面试中却是一个高频的面试题。希望大家能够彻底理解。 本篇文章所涉及的源代码： github.com/eamonzzz document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2019-10-27T15:11:44.000Z","updated":"2020-04-20T14:02:57.507Z","comments":true,"path":"posts/ccff2b22.html","link":"","permalink":"https://www.eamonzhang.com/posts/ccff2b22.html","excerpt":"我们都知道Java中共有 23 种设计模式，其中工厂模式分为三种，即：简单工厂模式（不在 23 种设计模式之列）、工厂方法模式和抽象工厂模式；我们平时说的工厂模式，其实大都指工厂方法模式，这种模式是我们平时编码中用的频率最高的一种，在Spring源码中就有很多工厂模式的应用，比如 BeanFactory。 下面依次按照简单工厂模式、工厂方法模式、抽象工厂模式的顺序，依次由浅入深说说这三种模式；文章分别从定义、场景、优缺点也示例进行讲解。","text":"我们都知道Java中共有 23 种设计模式，其中工厂模式分为三种，即：简单工厂模式（不在 23 种设计模式之列）、工厂方法模式和抽象工厂模式；我们平时说的工厂模式，其实大都指工厂方法模式，这种模式是我们平时编码中用的频率最高的一种，在Spring源码中就有很多工厂模式的应用，比如 BeanFactory。 下面依次按照简单工厂模式、工厂方法模式、抽象工厂模式的顺序，依次由浅入深说说这三种模式；文章分别从定义、场景、优缺点也示例进行讲解。 简单工厂模式定义简单工厂模式(Simple Factory Pattern)是指由一个工厂对象决定创建出哪一种产品类的实例，简单来说就是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。 场景简单工厂适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。总结一下就是： 需要创建的对象较少； 客户端不关心对象的创建过程； 优缺点优点实现了对责任的分割，提供了专门的工厂类用于创建对象 缺点工厂类的职责相对过重，不易于扩展过于复杂的产品结构，不符合开闭原则（可解决） 示例接下来我们构造一个场景来看看简单工厂模式的应用：现在手机更新换代的比较快，手机厂商每年基本都会在不同时间或者在同一时间发布生产不同型号和配置的手机。 假设某手机公司最近发布了型号为 A、B 的手机，其中生产任务交给代工厂去生产；我们都知道不管什么类型的手机都属于手机，所以我们先创建一个手机类Phone，并在其中声明一个公共的手机型号方法type： /** * @author eamon.zhang * @date 2019-09-27 上午10:55 */ public interface Phone { void type(); } 然后定义具体的手机类型： 型号 A： /** * @author eamon.zhang * @date 2019-09-27 上午11:02 */ public class PhoneA implements Phone { @Override public void type() { System.out.println(\"型号为A的手机！\"); } } 型号 B： /** * @author eamon.zhang * @date 2019-09-27 上午11:03 */ public class PhoneB implements Phone { @Override public void type() { System.out.println(\"型号为B的手机！\"); } } 创建手机代工厂 PhoneFactory 类： /** * @author eamon.zhang * @date 2019-09-27 上午10:54 */ public class PhoneFactory { public Phone product(String type) { switch (type) { case \"A\": return new PhoneA(); case \"B\": return new PhoneB(); default: return null; } } } 测试： /** * @author eamon.zhang * @date 2019-09-27 上午11:09 */ public class PhoneFactoryTest { @Test public void product() { PhoneFactory phoneFactory = new PhoneFactory(); phoneFactory.product(\"A\").type(); phoneFactory.product(\"B\").type(); } } 输出： 型号为A的手机！ 型号为B的手机！ 当然，为了方便调用，PhoneFactory 中的product()也可以写成静态的。 类图： 拓展解决不符合开闭原则问题上面的示例中，客户端调用是简单了，但如果我们业务继续扩展，增加一个型号 C，那么上面的工厂方法中的product() 方法就得再次修改逻辑。不符合开闭原则；因此我们客户考虑对其进行进一步优化，利用反射技术修改product()方法： public Phone product(String className) { try { if (!(null == className || \"\".equals(className))) { return (Phone) Class.forName(className).newInstance(); } } catch (Exception e) { e.printStackTrace(); } return null; } 修改客户端调用代码： public void product() { PhoneFactory phoneFactory = new PhoneFactory(); phoneFactory.product(\"com.eamon.javadesignpatterns.factory.PhoneA\").type(); phoneFactory.product(\"com.eamon.javadesignpatterns.factory.PhoneB\").type(); } 经过优化之后，今后再增加型号，就不用去修改工厂方法了；但是又有一个问题，方法参数是很长的字符串，可控性有待提升，而且还需要强制转型，不方便阅读和维护，所以进一步改造： public Phone product(Class&lt;? extends Phone> clazz) { try { if (null != clazz) { return clazz.newInstance(); } } catch (Exception e) { e.printStackTrace(); } return null; } 优化客户端调用代码： @Test public void product() { PhoneFactory phoneFactory = new PhoneFactory(); phoneFactory.product(PhoneA.class).type(); phoneFactory.product(PhoneB.class).type(); } 再来看一下类图： 其他简单工厂模式在 JDK 源码中也无处不足，比如常用的 Calendar类中Calendar.getInstance()方法，跟进源码到createCalendar(TimeZone zone,Locale aLocale)就可以看出。 还有就是 常用的logback，我们可以看到 LoggerFactory 中有多个重载的方法 getLogger(): public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } public final Logger getLogger(final Class&lt;?> clazz) { return getLogger(clazz.getName()); } 工厂方法模式定义工厂方法模式(Fatory Method Pattern)是指定义一个创建对象的接口，但让实现这个 接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。 在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符 合开闭原则。 工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个手机的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于维护。根据单一职责原则我们将职能继续拆分，专人干专事。 场景工厂方法适用于以下场景: 创建对象需要大量重复的代码。 客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。 一个类通过其子类来指定创建哪个对象。 优缺点优点 具有良好的封装性，代码结构清晰，井底了模块间的耦合。 拓展性非常优秀。（在增加产品类的情况下，只要修改具体的工厂类或扩展一个工厂类） 屏蔽了产品类。（产品类的实现如何变化，调用者不需要关心） 缺点:1、类的个数容易过多，增加复杂度。2、增加了系统的抽象性和理解难度。 示例A 型号手机由PhoneA工厂创建，B 型号手机由PhoneB工厂创建，对工厂本身也做一个抽象。来看代码，先创建 PhoneFactory 接口： /** * @author eamon.zhang * @date 2019-09-27 下午1:45 */ public interface PhoneFactory { Phone product(); } 分别创建子工厂 PhoneAFactory： /** * @author eamon.zhang * @date 2019-09-27 下午1:50 */ public class PhoneAFactory implements PhoneFactory { @Override public Phone product() { return new PhoneA(); } } PhoneBFactory 类： /** * @author eamon.zhang * @date 2019-09-27 下午1:50 */ public class PhoneBFactory implements PhoneFactory { @Override public Phone product() { return new PhoneB(); } } 看测试代码： /** * @author eamon.zhang * @date 2019-09-27 下午1:54 */ public class PhoneFactoryTest { @Test public void product() { PhoneFactory factory = new PhoneAFactory(); factory.product().type(); factory = new PhoneBFactory(); factory.product().type(); } } 测试结果： 型号为A的手机！ 型号为B的手机！ 再看一下类图： 拓展再来看看 logback 中工厂方法模式的应用，看看类图就 OK 了： 抽象工厂模式定义抽象工厂模式(Abastract Factory Pattern)是指提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。强调的是一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 理解为了便于大家理解抽象工厂，我们先了解两个概念产品等级结构和产品族，看下面的图:从上图中看出有正方形，圆形和三角形三种图形，相同颜色深浅的就代表同一个产品族，相同形状的代表同一个产品等级结构。同样可以从生活中来举例，比如，美的电器生产多种家用电器。那么上图中，颜色最深的正方形就代表美的洗衣机、颜色最深的圆形代表美的空调、颜色最深的三角形代表美的热水器，颜色最深的一排都属于美的品牌，都是美的电器这个产品族。再看最右侧的三角形，颜色最深的我们指定了代表美的热水器，那么第二排颜色稍微浅一点的三角形，代表海信的热水器。同理，同一产品结构下还有格力热水器，格力空调，格力洗衣机。 再看下面这张图，最左侧的箭头代表具体的工厂，有美的工厂、海信工厂、格力工厂。每个品牌的工厂都生产洗衣机、热水器、空调。 通过上面两张图的对比理解，相信大家对抽象工厂有了非常形象的理解。 场景一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。简单来说： 和工厂方法一样客户端不需要知道它所创建的对象的类。 需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则） 优缺点优点 封装性，每个产品的实现类不是高层模块要关心的，它要关心的是接口，不关心对象是如何创建的，只要知道工厂类是谁，就能创建出一个需要的对象，省时省力。 产品族内的约束为非公开状态。 缺点 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口 增加了系统的抽象性和理解难度 示例比如现在有一个应用，假如是某视频软件，需要在三个不同的平台（Windows、IOS、Android）上运行，该应用针对每套系统都设计了一套上传控制器（UploadController）、播放控制（DisplayController），下面通过抽象工厂模式来设计该软件。 视频软件里边的各个平台的UploadController和DisplayController应该是我们最终生产的具体产品。所以新建两个抽象产品接口。 UploadController 接口： /** * @author eamon.zhang * @date 2019-09-27 下午2:59 */ public interface UploadController { void upload(); } DisplayController 接口： /** * @author eamon.zhang * @date 2019-09-27 下午2:59 */ public interface DisplayController { void display(); } 定义抽象工厂VideoPlayerFactory类，它能够创建UploadController和DisplayController： /** * 抽象工厂是主入口，在Spring中应用的最广泛的一种设计模式，易于扩展 * * @author eamon.zhang * @date 2019-09-27 下午3:04 */ public interface VideoPlayerFactory { DisplayController createDisplayController(); UploadController createUploadController(); } 然后在各个平台创建具体的 UploadController和DisplayController： 创建适用于Windows的UploadController和DisplayController： /** * @author eamon.zhang * @date 2019-09-27 下午3:09 */ public class WindowsUploadController implements UploadController { @Override public void upload() { System.out.println(\"Windows 上传控制器！\"); } } /** * @author eamon.zhang * @date 2019-09-27 下午3:09 */ public class WindowsDisplayController implements DisplayController { @Override public void display() { System.out.println(\"Windows 上的播放器！\"); } } 创建适用于IOS的UploadController和DisplayController： /** * @author eamon.zhang * @date 2019-09-27 下午3:10 */ public class IosUploaderController implements UploadController { @Override public void upload() { System.out.println(\"IOS 上传控制器！\"); } } /** * @author eamon.zhang * @date 2019-09-27 下午3:09 */ public class IosDisplayController implements DisplayController { @Override public void display() { System.out.println(\"IOS 上的播放器！\"); } } 创建适用于Android的UploadController和DisplayController： /** * @author eamon.zhang * @date 2019-09-27 下午3:10 */ public class AndroidUploaderController implements UploadController { @Override public void upload() { System.out.println(\"Android 上传控制器！\"); } } /** * @author eamon.zhang * @date 2019-09-27 下午3:09 */ public class AndroidDisplayController implements DisplayController { @Override public void display() { System.out.println(\"Android 上的播放器！\"); } } 在各平台具体的工厂类中完成上传控制器和播放控制器的创建过程： 创建WindowsFactory类: /** * @author eamon.zhang * @date 2019-09-27 下午3:15 */ public class WindowsFactory implements VideoPlayerFactory { @Override public DisplayController createDisplayController() { return new WindowsDisplayController(); } @Override public UploadController createUploadController() { return new WindowsUploadController(); } } 创建IosFactory类: /** * @author eamon.zhang * @date 2019-09-27 下午3:17 */ public class IosFactory implements VideoPlayerFactory { @Override public DisplayController createDisplayController() { return new IosDisplayController(); } @Override public UploadController createUploadController() { return new IosUploaderController(); } } 创建AndroidFactory类: /** * @author eamon.zhang * @date 2019-09-27 下午3:18 */ public class AndroidFactory implements VideoPlayerFactory { @Override public DisplayController createDisplayController() { return new AndroidDisplayController(); } @Override public UploadController createUploadController() { return new AndroidUploaderController(); } } 来看客户端调用： /** * @author eamon.zhang * @date 2019-09-27 下午3:20 */ public class VideoPlayerFactoryTest { @Test public void VideoPlayer() { VideoPlayerFactory factory = new WindowsFactory(); // IOS // factory = new IosFactory(); // // Android // factory = new AndroidFactory(); UploadController uploadController = factory.createUploadController(); DisplayController displayController = factory.createDisplayController(); uploadController.upload(); displayController.display(); } } 以调用 Windows 为例，结果： Windows 上传控制器！ Windows 上的播放器！ 上面就是针对不同平台只通过创建对应的工厂对象就完成了上传控制器和播放控制器的创建。抽象工厂非常完美清晰地描述这样一层复杂的关系。但是，不知道大家有没有发现，如果我们再继续扩展功能，将下载器也加入到产品中，那么我们的代码从抽象工厂，到具体工厂要全部调整，很显然不符合开闭原则。因此就有了上面优缺点中所说的缺点。 总结在实际应用中，我们千万不能犯强迫症甚至有洁癖。在实际需求中产品等级结构升级是非常正常的一件事情。我们可以根据实际情况，只要不是频繁升级，可以不遵循开闭原则。代码每半年升级一次或者每年升级一次又有何不可呢? 源码：github.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-七大设计原则（四）-合成复用原则与设计原则总结","slug":"设计模式-七大设计原则（四）-合成复用原则与设计原则总结","date":"2019-10-27T15:10:34.000Z","updated":"2020-04-20T14:02:57.503Z","comments":true,"path":"posts/2736756b.html","link":"","permalink":"https://www.eamonzhang.com/posts/2736756b.html","excerpt":"简单介绍一下七大设计原则： 开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭 依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体 单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化 接口隔离原则：使用多个专门的接口，而不是使用一个总接口 迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的","text":"简单介绍一下七大设计原则： 开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭 依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体 单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化 接口隔离原则：使用多个专门的接口，而不是使用一个总接口 迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的 合成复用原则定义合成复用原则(Composite/Aggregate Reuse Principle,CARP)是指尽量使用对象组 合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱 复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计， 其实也都需要遵循 OOP 模型。 示例还是以数据库操作为例，先来创建 DBConnection 类: /** * @author eamon.zhang * @date 2019-09-26 上午10:42 */ public class DBConnection { public String getConnection() { return \"MySQL 数据库连接\"; } } 创建 ProductDao 类: /** * @author eamon.zhang * @date 2019-09-26 上午10:43 */ public class ProductDao { private DBConnection dbConnection; public void setDbConnection(DBConnection dbConnection) { this.dbConnection = dbConnection; } public void addProduct() { String conn = dbConnection.getConnection(); System.out.println(\"使用\" + conn + \"增加产品\"); } } 这就是一种非常典型的合成复用原则应用场景。但是，目前的设计来说，DBConnection 还不是一种抽象，不便于系统扩展。目前的系统支持 MySQL 数据库连接，假设业务发生 变化，数据库操作层要支持 Oracle 数据库。当然，我们可以在 DBConnection 中增加对 Oracle 数据库支持的方法。但是违背了开闭原则。其实，我们可以不必修改 Dao 的代码， 将 DBConnection 修改为 abstract，来看代码: /** * @author eamon.zhang * @date 2019-09-26 上午10:42 */ public abstract class DBConnection { public abstract String getConnection(); } 然后，将 MySQL 的逻辑抽离: /** * @author eamon.zhang * @date 2019-09-26 上午10:46 */ public class MySQLConnection extends DBConnection { @Override public String getConnection() { return \"MySQL 数据库连接\"; } } 再创建 Oracle 支持的逻辑: /** * @author eamon.zhang * @date 2019-09-26 上午10:47 */ public class OracleConnection extends DBConnection { @Override public String getConnection() { return \"Oracle 数据库连接\"; } } 具体选择交给应用层，来看一下类图: 设计原则总结学习设计原则，学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都 遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的 场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-七大设计原则（三）-迪米特法则与里氏替换原则","slug":"设计模式-七大设计原则（三）-迪米特法则与里氏替换原则","date":"2019-10-27T15:06:55.000Z","updated":"2020-04-20T14:40:33.745Z","comments":true,"path":"posts/9bc5df88.html","link":"","permalink":"https://www.eamonzhang.com/posts/9bc5df88.html","excerpt":"概述 简单介绍一下七大设计原则： 开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭 依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体 单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化 接口隔离原则：使用多个专门的接口，而不是使用一个总接口 迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的","text":"概述 简单介绍一下七大设计原则： 开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭 依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体 单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化 接口隔离原则：使用多个专门的接口，而不是使用一个总接口 迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的 迪米特法则定义迪米特原则(Law of Demeter LoD)是指一个对象应该对其他对象保持最少的了解，又 叫最少知道原则(Least Knowledge Principle,LKP)，尽量降低类与类之间的耦合。 迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输 出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。 示例现在来设计一个权限系统，Boss 需要查看目前发布到线上的课程数量。这时候，Boss 要找到 TeamLeader 去进行统计，TeamLeader 再把统计结果告诉 Boss。接下来我们还 是来看代码: Course类： /** * @author eamon.zhang * @date 2019-09-26 上午9:17 */ public class Course { } TeamLeader 类： /** * @author eamon.zhang * @date 2019-09-26 上午9:17 */ public class TeamLeader { public void checkNumberOfCourses(List&lt;Course> courseList) { System.out.println(\"目前已发布的课程数量是:\" + courseList.size()); } } Boss 类： /** * @author eamon.zhang * @date 2019-09-26 上午9:17 */ public class Boss { public void commandCheckNumber(TeamLeader teamLeader) { //模拟 Boss 一页一页往下翻页，TeamLeader 实时统计 List&lt;Course> courseList = new ArrayList&lt;Course>(); for (int i = 0; i &lt; 20; i++) { courseList.add(new Course()); } teamLeader.checkNumberOfCourses(courseList); } } 测试代码： public static void main(String[] args) { Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.commandCheckNumber(teamLeader); } 写到这里，其实功能已经都已经实现，代码看上去也没什么问题。根据迪米特原则，Boss 只想要结果，不需要跟 Course 产生直接的交流。而 TeamLeader 统计需要引用 Course 对象。Boss 和 Course 并不是朋友，从下面的类图就可以看出来: 下面来对代码进行改造:TeamLeader类： /** * @author eamon.zhang * @date 2019-09-26 上午9:17 */ public class TeamLeader { public void checkNumberOfCourses() { List&lt;Course> courseList = new ArrayList&lt;Course>(); for (int i = 0; i &lt; 20; i++) { courseList.add(new Course()); } System.out.println(\"目前已发布的课程数量是:\" + courseList.size()); } } Boss 类： /** * @author eamon.zhang * @date 2019-09-26 上午9:17 */ public class Boss { public void commandCheckNumber(TeamLeader teamLeader) { teamLeader.checkNumberOfCourses(); } } 再来看下面的类图，Course 和 Boss 已经没有关联了。 学习软件设计原则，千万不能形成强迫症。碰到业务复杂的场景，我们需要随机应变。 里氏替换原则定义里氏替换原则(Liskov Substitution Principle,LSP)是指如果对每一个类型为 T1 的对 象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个 父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下: 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类 方法的输入参数更宽松。 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即 方法的输出/返回值)要比父类更严格或相等。 示例在前面讲开闭原则的时候埋下了一个伏笔，我们记得在获取折后时重写覆盖了父类的 getPrice()方法，增加了一个获取原价格的方法 getOriginPrice()，显然就违背了里氏替换 原则。我们修改一下代码，不应该覆盖 getPrice()方法，增加 getDiscountPrice()方法: /** * @author eamon.zhang * @date 2019-09-25 上午10:36 */ public class NovelDiscountBook extends NovelBook { public NovelDiscountBook(String name, int price, String author) { super(name, price, author); } public double getDiscountPrice(){ return super.getPrice() * 0.85; } } 使用里氏替换原则有以下优点: 约束继承泛滥，开闭原则的一种体现。 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩 展性。降低需求变更时引入的风险。 现在来描述一个经典的业务场景，用正方形、矩形和四边形的关系说明里氏替换原则， 我们都知道正方形是一个特殊的长方形，那么就可以创建一个长方形父类 Rectangle 类: /** * @author eamon.zhang * @date 2019-09-26 上午9:59 */ public class Rectangle { private long height; private long width; public long getHeight() { return height; } public void setHeight(long height) { this.height = height; } public long getWidth() { return width; } public void setWidth(long width) { this.width = width; } } 创建正方形 Square 类继承长方形: /** * @author eamon.zhang * @date 2019-09-26 上午10:01 */ public class Square extends Rectangle { private long length; public long getLength() { return length; } public void setLength(long length) { this.length = length; } @Override public long getHeight() { return super.getHeight(); } @Override public void setHeight(long height) { super.setHeight(height); } @Override public long getWidth() { return super.getWidth(); } @Override public void setWidth(long width) { super.setWidth(width); } } 在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增， 知道高等于宽变成正方形: public static void resize(Rectangle rectangle) { while (rectangle.getWidth() >= rectangle.getHeight()) { rectangle.setHeight(rectangle.getHeight() + 1); System.out.println(\"width:\" + rectangle.getWidth() + \",height:\" + rectangle.getHeight()); } System.out.println(\"resize 方法结束\" + \"\\nwidth:\" + rectangle.getWidth() + \",height:\" + rectangle.getHeight()); } 测试代码: public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setWidth(20); rectangle.setHeight(10); resize(rectangle); } 运行结果: 发现高比宽还大了，在长方形中是一种非常正常的情况。现在我们再来看下面的代码， 把长方形 Rectangle 替换成它的子类正方形 Square，修改测试代码: public static void main(String[] args) { Square square = new Square(); square.setLength(10); resize(square); } 这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后， 程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则 只存在父类与子类之间，约束继承泛滥。我们再来创建一个基于长方形与正方形共同的 抽象四边形 Quadrangle 接口: /** * @author eamon.zhang * @date 2019-09-26 上午10:12 */ public interface Quadrangle { long getWidth(); long getHeight(); } 修改长方形 Rectangle 类: /** * @author eamon.zhang * @date 2019-09-26 上午9:59 */ public class Rectangle implements Quadrangle { private long height; private long width; @Override public long getWidth() { return width; } public long getHeight() { return height; } public void setHeight(long height) { this.height = height; } public void setWidth(long width) { this.width = width; } } 修改正方形类 Square 类: /** * @author eamon.zhang * @date 2019-09-26 上午10:01 */ public class Square implements Quadrangle { private long length; public long getLength() { return length; } public void setLength(long length) { this.length = length; } @Override public long getWidth() { return length; } @Override public long getHeight() { return length; } } 此时，如果我们把 resize()方法的参数换成四边形 Quadrangle 类，方法内部就会报错。 因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承 泛滥，resize()的方法参数只能用 Rectangle 长方形。当然，我们在后面的设计模式系列文章中 中还会继续深入讲解。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-七大设计原则（二）","slug":"设计模式-七大设计原则（二）","date":"2019-10-27T14:57:07.000Z","updated":"2020-04-20T14:02:57.503Z","comments":true,"path":"posts/bc40f739.html","link":"","permalink":"https://www.eamonzhang.com/posts/bc40f739.html","excerpt":"简单介绍一下七大设计原则： 开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭 依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体 单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化 接口隔离原则：使用多个专门的接口，而不是使用一个总接口 迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的","text":"简单介绍一下七大设计原则： 开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭 依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体 单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化 接口隔离原则：使用多个专门的接口，而不是使用一个总接口 迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的 单一职责原则定义单一职责(Simple Responsibility Pinciple，SRP)是指不要存在多于一个导致类变更 的原因。 假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导 致类变更的原因。如何解决这个问题呢?我们就要给两个职责分别用两个 Class 来实现， 进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的 可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个 Class/Interface/Method 只负责一项职责。 示例接下来我们参考《设计模式之禅》一书中所提到关于用户信息管理的示例来举例： 新建用户信息IUserInfo类： /** * @author eamon.zhang * @date 2019-09-25 下午4:07 */ public interface IUserInfo { void setUserID(String userID); String getUserID(); void setPassword(String password); String getPassword(); void setUserName(String userName); String getUserName(); boolean changePassword(String oldPassword); boolean deleteUser(); void mapUser(); boolean addOrg(int orgID); boolean addRole(int roleID); } 用户信息维护类图： 如果像这样子来设计，即使是一个初级程序员也可以看出这个解耦设计得有问题，用户的属性和用户的行为没有分离开。应该把用户的信息抽离成为一个BO，把行为抽离成为一个Biz（业务逻辑）。然后我们修改这个接口。创建 IUserBo 类： /** * @author eamon.zhang * @date 2019-09-25 下午4:18 */ public interface IUserBO { void setUserID(String userID); String getUserID(); void setPassword(String password); String getPassword(); void setUserName(String userName); String getUserName(); } 创建 IUserBiz 类： /** * @author eamon.zhang * @date 2019-09-25 下午4:18 */ public interface IUserBiz { boolean changePassword(String oldPassword); boolean deleteUser(); void mapUser(); boolean addOrg(int orgID); boolean addRole(int roleID); } 职责划分后的类图： 我们将IUserInfo拆分为了IUserBo和IUserBiz。我们就实现了两个类的单一职责,也就是让引起他们变化原因只有一种,并且让相关性强的内容聚合在一个类内部。 但是，我们在实际开发中会项目依赖，组合，聚合这些关系，还有还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编写代码的过程，尽可能地让接口和方法保持 单一职责，对我们项目后期的维护是有很大帮助的。 接口隔离原则定义接口隔离原则(Interface Segregation Principle, ISP)是指用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时 应当注意一下几点: 一个类对一类的依赖应该建立在最小的接口之上。 建立单一接口，不要建立庞大臃肿的接口。 尽量细化接口，接口中的方法尽量少(不是越少越好，一定要适度)。 接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、 可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解 是非常重要的。 示例下面我们来看一段代码，写一个动物行为的抽象: IAnimal 接口： /** * @author eamon.zhang * @date 2019-09-25 下午4:56 */ public interface IAnimal { void eat(); void fly(); void swim(); } Bird 类实现: /** * @author eamon.zhang * @date 2019-09-25 下午4:57 */ public class Bird implements IAnimal { public void eat() { } public void fly() { } public void swim() { } } Dog 类实现: /** * @author eamon.zhang * @date 2019-09-25 下午4:57 */ public class Dog implements IAnimal { public void eat() { } public void fly() { } public void swim() { } } 可以看出，Bird 的 swim()方法可能只能空着，Dog 的 fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和 ISwimAnimal 接口，来看代码: IEatAnimal 接口： /** * @author eamon.zhang * @date 2019-09-25 下午4:59 */ public interface IEatAnimal { void eat(); } IFlyAnimal 接口： /** * @author eamon.zhang * @date 2019-09-25 下午5:01 */ public interface IFlyAnimal { void fly(); } ISwimAnimal 接口： /** * @author eamon.zhang * @date 2019-09-25 下午5:02 */ public interface ISwimAnimal { void swim(); } Dog 只实现 IEatAnimal 和 ISwimAnimal 接口: /** * @author eamon.zhang * @date 2019-09-25 下午4:57 */ public class Dog implements IEatAnimal,ISwimAnimal { public void eat() { } public void swim() { } } 来看下两种类图的对比，还是非常清晰明了的: 声明内容为原创，转发请注明出处！部分内容参考网络，侵删！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-七大设计原则（一）","slug":"设计模式-七大设计原则（一）","date":"2019-10-27T08:16:21.000Z","updated":"2020-04-20T14:02:57.502Z","comments":true,"path":"posts/8c561be1.html","link":"","permalink":"https://www.eamonzhang.com/posts/8c561be1.html","excerpt":"概述 简单介绍一下七大设计原则：开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化接口隔离原则：使用多个专门的接口，而不是使用一个总接口迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的","text":"概述 简单介绍一下七大设计原则：开闭原则：是所有面向对象设计的核心，对扩展开放，对修改关闭依赖倒置原则：针对接口编程，依赖于抽象而不依赖于具体单一职责原则：一个接口只负责一件事情，只能有一个原因导致类变化接口隔离原则：使用多个专门的接口，而不是使用一个总接口迪米特法则（最少知道原则）：只和朋友交流（成员变量、方法输入输出参数），不和陌生人说话，控制好访问修饰符里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能合成复用原则：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的 开闭原则定义指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。 在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。 实例实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码： 以书店销售书籍为例，创建书籍接口： /** * @author eamon.zhang * @date 2019-09-25 上午10:26 */ public interface IBook { // 书籍名称 public String getName(); // 价格 public int getPrice(); // 作者 public String getAuthor(); } 书籍分为很多类，比如有小说类等，创建小说类书籍： /** * @author eamon.zhang * @date 2019-09-25 上午10:30 */ public class NovelBook implements IBook { // 书名 private String name; // 售价 private int price; // 作者 private String author; // 通过构造函数传递数据数据 public NovelBook(String name, int price, String author) { this.name = name; this.price = price; this.author = author; } // 获取书名 public String getName() { return this.name; } // 获取价格 public int getPrice() { return this.price; } // 获取作者 public String getAuthor() { return this.author; } } 现在我们要给小说类书籍做一个活动，价格优惠。如果修改 NovelBook 中的 getPrice()方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，NovelDiscountBook 类（思考一下为什么要叫 NovelDiscountBook，而不叫 DiscountBook）： /** * @author eamon.zhang * @date 2019-09-25 上午10:36 */ public class NovelDiscountBook extends NovelBook { public NovelDiscountBook(String name, int price, String author) { super(name, price, author); } public double getOriginPrice(){ return super.getPrice(); } public double getPrice(){ return super.getPrice() * 0.85; } } 类结构图 依赖倒置原则定义依赖倒置原则（DependenceInversionPrinciple,DIP）是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。 实例我们以阅读书籍为例，先创建一个 Eamon 类： /** * @author eamon.zhang * @date 2019-09-25 上午11:09 */ public class Eamon { public void readNotreDame(){ System.out.println(\"Eamon 在阅读 《巴黎圣母院》\"); } public void readTheOldManAndTheSea(){ System.out.println(\"Eamon 在阅读 《老人与海》\"); } } 写个测试类调用一下： public static void main(String[] args) { Eamon eamon = new Eamon(); eamon.readNotreDame(); eamon.readTheOldManAndTheSea(); } Eamon 目前正在阅读者两本书。但是学习是无止境的，Eamon 读完这些书之后还想读《天龙八部》。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Eamon 类中添加 readTianLongBaBu()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建一个课程的抽象 IBook 接口： /** * @author eamon.zhang * @date 2019-09-25 上午11:20 */ public interface IBook { void read(); } 然后写NotreDameBook类： /** * @author eamon.zhang * @date 2019-09-25 上午11:22 */ public class NotreDameBook implements IBook { public void read() { System.out.println(\"Eamon 在阅读 《巴黎圣母院》\"); } } 再写 TheOldManAndTheSeaBook 类： /** * @author eamon.zhang * @date 2019-09-25 上午11:23 */ public class TheOldManAndTheSeaBook implements IBook{ public void read() { System.out.println(\"Eamon 在阅读 《老人与海》\"); } } 修改Eamon类 /** * @author eamon.zhang * @date 2019-09-25 上午11:09 */ public class Eamon { public void read(IBook iBook){ iBook.read(); } } 来看调用： public static void main(String[] args) { Eamon eamon = new Eamon(); eamon.read(new NotreDameBook()); eamon.read(new TheOldManAndTheSeaBook()); } 我们这时候再看来代码，Eamon 再想读任何书，对于新书，我只需要新建一个类，通过传参的方式告诉 Eamon，而不需要修改底层代码。实际上这是一种大家非常熟悉的方式，叫依赖注入。注入的方式还有构造器方式和 setter 方式。我们来看构造器注入方式： /** * @author eamon.zhang * @date 2019-09-25 上午11:09 */ public class Eamon { public Eamon(IBook iBook) { this.iBook = iBook; } private IBook iBook; public void read(){ iBook.read(); } } 看调用代码： public static void main(String[] args) { Eamon eamon = new Eamon(new NotreDameBook()); eamon.read(); } 根据构造器方式注入，在调用时，每次都要创建实例。那么，如果 Eamon 是全局单例，则我们就只能选择用 Setter 方式来注入，继续修改 Eamon 类的代码： /** * @author eamon.zhang * @date 2019-09-25 上午11:09 */ public class Eamon { private IBook iBook; public void setBook(IBook iBook) { this.iBook = iBook; } public void read(){ iBook.read(); } } 看调用代码： public static void main(String[] args) { Eamon eamon = new Eamon(); eamon.setBook(new NotreDameBook()); eamon.read(); eamon.setBook(new TheOldManAndTheSeaBook()); eamon.read(); } 最终类图 切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此大家在拿到需求之后，要面向接口编程，先顶层再细节来设计代码结构。 声明文中部分内容参考网络！ 封面图源网络，侵删！ 内容为原创，转发请注明出处！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-导读","slug":"设计模式-导读","date":"2019-10-27T07:11:00.000Z","updated":"2020-04-20T14:02:57.506Z","comments":true,"path":"posts/cef09865.html","link":"","permalink":"https://www.eamonzhang.com/posts/cef09865.html","excerpt":"其实不用设计模式并非不可以，但是用好设计模式能帮助我们更好地解决实际问题。 设计模式天天都在用，但自己却无感知。","text":"其实不用设计模式并非不可以，但是用好设计模式能帮助我们更好地解决实际问题。 设计模式天天都在用，但自己却无感知。 本系列文章，初衷是为了记录日常经常使用的设计模式，也给学习设计模式的同学们提供参考和查阅。 文章内容有自己的理解，也有参考网络，如有侵犯，请告知删除。 学习设计模式的重要性设计模式最重要的是解耦。 学习设计模式是如何总结经验的，把经验为自己所用。 学设计模式也是锻炼将业务需求转换技术实现的一种非常有效的方式。 设计模式的基石我们在学习设计模式之前，建议大家，一定要掌握好设计模式的几大原则，《设计模式之禅》一书中开篇就是讲的是设计原则； 所以在本篇文章中，在这里先对设计原则做一个回顾和总结。 设计原则 解释 开闭原则 对扩展开放，对修改关闭。 依赖倒置原则 通过抽象使各个类或者模块不相互影响，实现松耦合。 单一职责原则 一个类、接口、方法只做一件事。 接口隔离原则 尽量保证接口的纯洁性，客户端不应该依赖不需要的接口。 迪米特法则 又叫最少知道原则，一个类对其所依赖的类知道得越少越好。 里氏替换原则 子类可以扩展父类的功能但不能改变父类原有的功能。 合成复用原则 尽量使用对象组合、聚合，而不使用继承关系达到代码复用的目的。 经典框架都在用设计模式解决问题Spring 就是一个把设计模式用得淋漓尽致的经典框架，其实从类的命名就能看出来，我来一一列举： 设计模式名称 举例 工厂模式 BeanFactory 装饰器模式 BeanWrapper 代理模式 AopProxy 委派模式 DispatcherServlet 策略模式 HandlerMapping 适配器模式 HandlerAdapter 模板模式 JdbcTemplate 观察者模式 ContextLoaderListener 设计模式分类 类型 名称 英文 创建型模式 工厂模式 Factory Patterns 单例模式 Singleton Pattern 原型模式 Prototype Pattern 结构型模式 适配器模式 Prototype Pattern 装饰器模式 Decorator Pattern 代理模式 Proxy Pattern 行为型模式 策略模式 Strategy Pattern 模板模式 Template Pattern 委派模式 Delegate Pattern 观察者模式 Observer Pattern 注意需要特别声明的是，设计模式从来都不是单个设计模式独立使用的。在实际应用中，通常是多个设计模式混合使用，你中有我，我中有你。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"https://www.eamonzhang.com/tags/Java/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.eamonzhang.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}